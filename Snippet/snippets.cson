# Your snippets
#
# Atom snippets allow you to enter a simple prefix in the editor and hit tab to
# expand the prefix into a larger code block with templated values.
#
# You can create a new snippet in this file by typing "snip" and then hitting
# tab.
#
# An example CoffeeScript snippet to expand log to console.log:
#
# '.source.coffee':
#   'Console log':
#     'prefix': 'log'
#     'body': 'console.log $1'
#
# Each scope (e.g. '.source.coffee' above) can only be declared once.
#
# This file uses CoffeeScript Object Notation (CSON).
# If you are unfamiliar with CSON, you can read more about it in the
# Atom Flight Manual:
# http://flight-manual.atom.io/using-atom/sections/basic-customization/#_cson

# Python Snippet
'.source.python':
  'Input multiple numbers to vars':
    'prefix': 'map(int)'
    'body': 'map(int,input().split())'
  'Input multiple numbers to list':
    'prefix': 'list(int)'
    'body': 'list(map(int,input().split()))'
  'Input numbers in multiple lines':
    'prefix': 'zint'
    'body': '[int(input()) for _ in range($1)]'
  'Input strings in multiple lines':
    'prefix': 'zstr'
    'body': '[input() for _ in range($1)]'
  'Input number':
    'prefix': 'int(input())'
    'body': 'int(input())'
  'Input string':
    'prefix': 'istrigq'
    'body': 'input()'
  'Input number ':
    'prefix': 'n = int(input())'
    'body': 'n = int(input())'
  'Input string ':
    'prefix': 'stringq '
    'body': 's = input()'
  'Get out of FORs':
    'prefix': 'else/continue/break'
    'body': """
      else:
          continue
      break
    """
  'Import':
    'prefix': 'import'
    'body': """
import sys
from fractions import gcd
from itertools import groupby as gb
from itertools import permutations as perm
from collections import Counter as C
from collections import defaultdict as dd
sys.setrecursionlimit(10**5)
    """

  # Disable
  '1':
    'prefix': 'sc'
    'disabled': true
  '2':
    'prefix': 'note'
    'disabled': true
  '3':
    'prefix': 'question'
    'disabled': true
  '4':
    'prefix': 'warning'
    'disabled': true
  '5':
    'prefix': 'while'
    'disabled': true
  '6':
    'prefix': 'with'
    'disabled': true
  '7':
    'prefix': 'enc'
    'disabled': true
  '8':
    'prefix': 'env'
    'disabled': true
  '9':
    'prefix': 'env3'
    'disabled': true
  '10':
    'prefix': 'review'
    'disabled': true
  '11':
    'prefix': 'rpdb'
    'disabled': true
  '12':
    'prefix': 'temp'
    'disabled': true
  '13':
    'prefix': 'todo'
    'disabled': true
  '14':
    'prefix': 'try'
    'disabled': true
  '15':
    'prefix': 'trye'
    'disabled': true
  '16':
    'prefix': 'tryef'
    'disabled': true
  '17':
    'prefix': 'tryf'
    'disabled': true
  '18':
    'prefix': 'idea'
    'disabled': true
  '19':
    'prefix': 'if'
    'disabled': true
  '20':
    'prefix': 'ifmain'
    'disabled': true
  '21':
    'prefix': 'sc'
    'disabled': true
  '22':
    'prefix': 'im'
    'disabled': true
  '23':
    'prefix': 'ipdb'
    'disabled': true
  '24':
    'prefix': 'optimize'
    'disabled': true
  '25':
    'prefix': 'pdb'
    'disabled': true
  '26':
    'prefix': 'property'
    'disabled': true
  '27':
    'prefix': 'pudb'
    'disabled': true
  '28':
    'prefix': 'as'
    'disabled': true
  '29':
    'prefix': 'ase'
    'disabled': true
  '30':
    'prefix': 'asf'
    'disabled': true
  '31':
    'prefix': 'asi'
    'disabled': true
  '32':
    'prefix': 'asin'
    'disabled': true
  '33':
    'prefix': 'asinno'
    'disabled': true
  '34':
    'prefix': 'asino'
    'disabled': true
  '35':
    'prefix': 'asint'
    'disabled': true
  '36':
    'prefix': 'asine'
    'disabled': true
  '37':
    'prefix': 'asne'
    'disabled': true
  '38':
    'prefix': 'asni'
    'disabled': true
  '39':
    'prefix': 'asr'
    'disabled': true
  '40':
    'prefix': 'ast'
    'disabled': true
  '41':
    'prefix': 'dc'
    'disabled': true
  '42':
    'prefix': 'debug'
    'disabled': true
  '43':
    'prefix': 'def'
    'disabled': true
  '44':
    'prefix': 'defs'
    'disabled': true
  '45':
    'prefix': 'fail'
    'disabled': true
  '46':
    'prefix': 'fim'
    'disabled': true
  '47':
    'prefix': 'fix'
    'disabled': true
  '48':
    'prefix': 'for'
    'disabled': true
  '49':
    'prefix': 'hack'
    'disabled': true
  '50':
    'prefix': 'lc'
    'disabled': true
  '51':
    'prefix': 'lcie'
    'disabled': true
  '52':
    'prefix': 'xxx'
    'disabled': true
  '53':
    'prefix': 'class'
    'disabled': true
  '54':
    'prefix': 'combak'
    'disabled': true
  '55':
    'prefix': 'bug'
    'disabled': true

# C++ Snippets
'.source.cpp':
  'Template(b)':
    'prefix': 'templatee'
    'body': """
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define REP(i,n) for(int (i)=0;(i)<(n);++(i))
#define FOR(i,a,b) for(int (i)=(a);(i)<(b);++(i))
#define EACH(e,v) for(auto& e:v)

signed main() {

  $1

}
    """
  'Template':
    'prefix': 'template'
    'body': """
#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n//TEMPLATE START---------------8<---------------8<---------------8<---------------8<---------------//\ntypedef long long ll;       typedef long double ld;  typedef pair<int,int> pii; typedef pair<ll,ll> pll;  typedef vector<int> vi;   typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb; typedef vector<ld> vld;    typedef vector<pii> vpii; typedef vector<pll> vpll; typedef vector<vector<int> > vvi;\nconst int INF = (0x7FFFFFFFL); const ll INFF = (0x7FFFFFFFFFFFFFFFL); const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst int MOD = 1e9 + 7;       const int MODD = 998244353;            const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";\nconst double PI = acos(-1.0);  const double EPS = 1e-9;               const string Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nint dx[9] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nint dy[9] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n#define ln '\\\\n'\n#define scnaf scanf\n#define sacnf scanf\n#define sancf scanf\n#define SS(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t){cin >> t;}template<typename First, typename...Rest> void MACRO_VAR_Scan(First& first, Rest&...rest){cin >> first;MACRO_VAR_Scan(rest...);}\n#define SV(type,c,n) vector<type> c(n);for(auto& i:c)cin >> i;\n#define SVV(type,c,n,m) vector<vector<type>> c(n,vector<type>(m));for(auto& r:c)for(auto& i:r)cin >> i;\ntemplate<class T,class U>ostream &operator<<(ostream &o,const pair<T,U>&j){o<<\"{\"<<j.first<<\", \"<<j.second<<\"}\";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const map<T,U>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const set<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const vector<T>&j){o<<\"{\";for(int i=0;i<(int)j.size();++i)o<<(i>0?\", \":\"\")<<j[i];o<<\"}\";return o;}\ninline int print(void){cout << endl; return 0;}\ntemplate<class Head> int print(Head&& head){cout << head;print();return 0;} template<class Head,class... Tail> int print(Head&& head,Tail&&... tail){cout<<head<<\" \";print(forward<Tail>(tail)...);return 0;}\ninline int debug(void){cerr << endl; return 0;}\ntemplate<class Head> int debug(Head&& head){cerr << head;debug();return 0;} template<class Head,class... Tail> int debug(Head&& head,Tail&&... tail){cerr<<head<<\" \";debug(forward<Tail>(tail)...);return 0;}\ntemplate<typename T> void PA(T &a){int ASIZE=sizeof(a)/sizeof(a[0]);for(int ii=0;ii<ASIZE;++ii){cout<<a[ii]<<\" \\\\n\"[ii==ASIZE-1];}}\ntemplate<typename T> void PV(T &v){int VSIZE=v.size();for(int ii=0;ii<VSIZE;++ii){cout<<v[ii]<<\" \\\\n\"[ii==VSIZE-1];}}\n#define ER(x)  cerr << #x << \" = \" << (x) << endl;\n#define ERV(v) {cerr << #v << \" : \";for(const auto& xxx : v){cerr << xxx << \" \";}cerr << \"\\\\n\";}\ninline int YES(bool x){cout<<((x)?\"YES\":\"NO\")<<endl;return 0;} inline int Yes(bool x){cout<<((x)?\"Yes\":\"No\")<<endl;return 0;}  inline int yes(bool x){cout<<((x)?\"yes\":\"no\")<<endl;return 0;}\ninline int yES(bool x){cout<<((x)?\"yES\":\"nO\")<<endl;return 0;} inline int Yay(bool x){cout<<((x)?\"Yay!\":\":(\")<<endl;return 0;}\ntemplate<typename A,typename B> void sankou(bool x,A a,B b){cout<<((x)?(a):(b))<<endl;}\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REPI(i,0,n)\n#define REPI(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REPI,_REP,)(__VA_ARGS__)\n#define _RREP(i,n) RREPI(i,n,0)\n#define RREPI(i,a,b) for(ll i=ll(a);i>=ll(b);--i)\n#define RREP(...) _overload3(__VA_ARGS__,RREPI,_RREP,)(__VA_ARGS__)\n#define EACH(e,v) for(auto& e : v)\n#define PERM(v) sort((v).begin(),(v).end());for(bool c##p=1;c##p;c##p=next_permutation((v).begin(),(v).end()))\n#define ADD(a,b) a=(a+ll(b))%MOD\n#define MUL(a,b) a=(a*ll(b))%MOD\ninline ll MOP(ll x,ll n,ll m=MOD){ll r=1;while(n>0){if(n&1)(r*=x)%=m;(x*=x)%=m;n>>=1;}return r;}\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}inline ll POW(ll a,ll b){ll c=1ll;do{if(b&1)c*=1ll*a;a*=1ll*a;}while(b>>=1);return c;}\ntemplate<typename T,typename A,typename B> inline bool between(T x,A a,B b) {return ((a<=x)&&(x<b));}template<class T> inline T sqr(T x){return x*x;}\ntemplate<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}\n#define tmax(x,y,z) max((x),max((y),(z)))\n#define tmin(x,y,z) min((x),min((y),(z)))\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define SORT(v) sort((v).begin(),(v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define EXIST(s,e) (find((s).begin(),(s).end(),(e))!=(s).end())\n#define EXISTST(s,c) (((s).find(c))!=string::npos)\n#define POSL(x,val) (lower_bound(x.begin(),x.end(),val)-x.begin())\n#define POSU(x,val) (upper_bound(x.begin(),x.end(),val)-x.begin())\n#define GEQ(x,val) (int)(x).size() - POSL((x),(val))\n#define GREATER(x,val) (int)(x).size() - POSU((x),(val))\n#define LEQ(x,val) POSU((x),(val))\n#define LESS(x,val) POSL((x),(val))\n#define SZV(a) int((a).size())\n#define SZA(a) sizeof(a)/sizeof(a[0])\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MEMINF(a) memset(a,0x3f,sizeof(a))\n#define FILL(a,b) memset(a,b,sizeof(a))\n#define UNIQUE(v) sort((v).begin(),(v).end());(v).erase(unique((v).begin(),(v).end()),(v).end())\nstruct abracadabra{\n  abracadabra(){\n    cin.tie(0); ios::sync_with_stdio(0);\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(5);\n  };\n} ABRACADABRA;\n\n//TEMPLATE END---------------8<---------------8<---------------8<---------------8<---------------//\n\nsigned main() {\n\n\t$1\n\n}
      """

  # Math
    # Combination
  'nCr,nPr,nHr O(MAX_N + logMOD)':
    'prefix': 'Math'
    'body': "/*\n・組み合わせ, 順列, 重複組み合わせ\n  > 前計算 O(MAX_N + logMOD)\n  > クエリ O(1)\n[備考] nが負の際, C(n,r) = (-1)^r * C(-n+r-1,r)\n[使用例]\nCOMinit();                   // MAX_Nまでの前計算\ncout << nCr(n,r) << endl;    // nCr (0 <= (n,r) <= MAX_N)\ncout << nPr(n,r) << endl;    // nPr ( ... )\ncout << nHr(n,r) << endl;    // nHr ( ... )\n*/\n\nconst int MAX_N = 2020202;\nll fac[MAX_N], finv[MAX_N], inv[MAX_N];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,MAX_N) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll nCr(ll n, ll r) {\n  if (r==0) return 1;\n  if (r<0) return 0;\n  if (n<0) return (r%2 ? -1 : 1) * nCr(-n+r-1,r);\n  if (n==0 || n<r) return 0;\n  return (fac[n]*((finv[n-r]*finv[r])%MOD))%MOD;\n}\nll nPr(ll n, ll r) { if (r<0 || n<r) return 0; else return (fac[n]*finv[n-r])%MOD; }\nll nHr(ll n, ll r) { if (n==0 && r==0) return 1; else return nCr(n+r-1,r); }"
  'nCr,nPr,nHr O(MAX_N + logMOD) ':
    'prefix': 'Combination/COMinit'
    'body': "/*\n・組み合わせ, 順列, 重複組み合わせ\n  > 前計算 O(MAX_N + logMOD)\n  > クエリ O(1)\n[備考] nが負の際, C(n,r) = (-1)^r * C(-n+r-1,r)\n[使用例]\nCOMinit();                   // MAX_Nまでの前計算\ncout << nCr(n,r) << endl;    // nCr (0 <= (n,r) <= MAX_N)\ncout << nPr(n,r) << endl;    // nPr ( ... )\ncout << nHr(n,r) << endl;    // nHr ( ... )\n*/\n\nconst int MAX_N = 2020202;\nll fac[MAX_N], finv[MAX_N], inv[MAX_N];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,MAX_N) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll nCr(ll n, ll r) {\n  if (r==0) return 1;\n  if (r<0) return 0;\n  if (n<0) return (r%2 ? -1 : 1) * nCr(-n+r-1,r);\n  if (n==0 || n<r) return 0;\n  return (fac[n]*((finv[n-r]*finv[r])%MOD))%MOD;\n}\nll nPr(ll n, ll r) { if (r<0 || n<r) return 0; else return (fac[n]*finv[n-r])%MOD; }\nll nHr(ll n, ll r) { if (n==0 && r==0) return 1; else return nCr(n+r-1,r); }"
  'nCr,nPr,nHr O(MAX_N + logMOD)  ':
    'prefix': 'nCr/nPr/nHr'
    'body': "/*\n・組み合わせ, 順列, 重複組み合わせ\n  > 前計算 O(MAX_N + logMOD)\n  > クエリ O(1)\n[備考] nが負の際, C(n,r) = (-1)^r * C(-n+r-1,r)\n[使用例]\nCOMinit();                   // MAX_Nまでの前計算\ncout << nCr(n,r) << endl;    // nCr (0 <= (n,r) <= MAX_N)\ncout << nPr(n,r) << endl;    // nPr ( ... )\ncout << nHr(n,r) << endl;    // nHr ( ... )\n*/\n\nconst int MAX_N = 2020202;\nll fac[MAX_N], finv[MAX_N], inv[MAX_N];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,MAX_N) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll nCr(ll n, ll r) {\n  if (r==0) return 1;\n  if (r<0) return 0;\n  if (n<0) return (r%2 ? -1 : 1) * nCr(-n+r-1,r);\n  if (n==0 || n<r) return 0;\n  return (fac[n]*((finv[n-r]*finv[r])%MOD))%MOD;\n}\nll nPr(ll n, ll r) { if (r<0 || n<r) return 0; else return (fac[n]*finv[n-r])%MOD; }\nll nHr(ll n, ll r) { if (n==0 && r==0) return 1; else return nCr(n+r-1,r); }"

  'nCr O(r)':
    'prefix': 'Math '
    'body': "/*\n・nが大きい(rが小さい)ときの組み合わせ\n  > クエリ O(r)\n[使用例] cout << comb(n,r) << endl;\n*/\n\nll comb(ll n, int r) {\n  if (r==0) return 1;\n  if (n<0) return comb(-n+r-1,r) * (r%2 ? -1 : 1);\n  if (n==0 || r<0 || n<r) return 0;\n  ll ret=1;\n  REP(i,1,r+1) (ret*=n--)/=i;\n  return ret;\n}"
  'nCr O(r) ':
    'prefix': 'Combination'
    'body': "/*\n・nが大きい(rが小さい)ときの組み合わせ\n  > クエリ O(r)\n[使用例] cout << comb(n,r) << endl;\n*/\n\nll comb(ll n, int r) {\n  if (r==0) return 1;\n  if (n<0) return comb(-n+r-1,r) * (r%2 ? -1 : 1);\n  if (n==0 || r<0 || n<r) return 0;\n  ll ret=1;\n  REP(i,1,r+1) (ret*=n--)/=i;\n  return ret;\n}"
  'nCr O(r)  ':
    'prefix': 'nCr'
    'body': "/*\n・nが大きい(rが小さい)ときの組み合わせ\n  > クエリ O(r)\n[使用例] cout << comb(n,r) << endl;\n*/\n\nll comb(ll n, int r) {\n  if (r==0) return 1;\n  if (n<0) return comb(-n+r-1,r) * (r%2 ? -1 : 1);\n  if (n==0 || r<0 || n<r) return 0;\n  ll ret=1;\n  REP(i,1,r+1) (ret*=n--)/=i;\n  return ret;\n}"

    # Prime
  '素数判定 O(√n)':
    'prefix': 'Math  '
    'body': "/*\n・素数判定\n  > O(√n)\n[使用例] YES(isPrime(998244353));\n*/\n\nbool isPrime(ll n) {\n  if (n < 2) return false;\n  for (ll i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}"
  '素数判定 O(√n) ':
    'prefix': 'Prime'
    'body': "/*\n・素数判定\n  > O(√n)\n[使用例] YES(isPrime(998244353));\n*/\n\nbool isPrime(ll n) {\n  if (n < 2) return false;\n  for (ll i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}"
  '素数判定 O(√n)  ':
    'prefix': 'isPrime'
    'body': "/*\n・素数判定\n  > O(√n)\n[使用例] YES(isPrime(998244353));\n*/\n\nbool isPrime(ll n) {\n  if (n < 2) return false;\n  for (ll i = 2; i * i <= n; ++i) {\n    if (n % i == 0) return false;\n  }\n  return true;\n}"

  'エラトステネスの篩 O(nloglogn)':
    'prefix': 'Math   '
    'body': "/*\n・エラトステネスの篩\n  > O(nloglogn)\n[使用例] vb prime = Eratosthenes(100000);\n[備考] nが10^6以下のときに使うべき\n*/\n\ninline vb Eratosthenes(const int n) {\n  vb r(n+1,true);\n  for(int i=2;i*i<=n;++i){\n    if(r[i]){\n      for(int j=i*2;j<=n;j+=i)r[j]=false;\n    }\n  }\n  if(r.size()>2){r[0]=0;r[1]=0;}\n  else if(r.size()>1){r[0]=0;}\n  return r;\n}"
  'エラトステネスの篩 O(nloglogn) ':
    'prefix': 'Prime '
    'body': "/*\n・エラトステネスの篩\n  > O(nloglogn)\n[使用例] vb prime = Eratosthenes(100000);\n[備考] nが10^6以下のときに使うべき\n*/\n\ninline vb Eratosthenes(const int n) {\n  vb r(n+1,true);\n  for(int i=2;i*i<=n;++i){\n    if(r[i]){\n      for(int j=i*2;j<=n;j+=i)r[j]=false;\n    }\n  }\n  if(r.size()>2){r[0]=0;r[1]=0;}\n  else if(r.size()>1){r[0]=0;}\n  return r;\n}"
  'エラトステネスの篩 O(nloglogn)  ':
    'prefix': 'Eratosthenes'
    'body': "/*\n・エラトステネスの篩\n  > O(nloglogn)\n[使用例] vb prime = Eratosthenes(100000);\n[備考] nが10^6以下のときに使うべき\n*/\n\ninline vb Eratosthenes(const int n) {\n  vb r(n+1,true);\n  for(int i=2;i*i<=n;++i){\n    if(r[i]){\n      for(int j=i*2;j<=n;j+=i)r[j]=false;\n    }\n  }\n  if(r.size()>2){r[0]=0;r[1]=0;}\n  else if(r.size()>1){r[0]=0;}\n  return r;\n}"

      # Divisor
  '素因数分解(約数の個数) O(√n)':
    'prefix': 'Math    '
    'body': "/*\n・素因数分解\n  > O(√n)\n[使用例] map<ll,int> mp = prime_factor(105);\n[応用例] (mpの各要素のsecond)+1を掛け合わせると, nの約数の個数\n*/\n\nmap<ll,int> prime_factor(ll n) {\n  map<ll,int> ret;\n  for (ll i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      ++ret[i];\n      n /= i;\n    }\n  }\n  if (n != 1) ret[n] = 1;\n  return ret;\n}"
  '素因数分解(約数の個数) O(√n) ':
    'prefix': 'Prime/prime_factor'
    'body': "/*\n・素因数分解\n  > O(√n)\n[使用例] map<ll,int> mp = prime_factor(105);\n[応用例] (mpの各要素のsecond)+1を掛け合わせると, nの約数の個数\n*/\n\nmap<ll,int> prime_factor(ll n) {\n  map<ll,int> ret;\n  for (ll i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      ++ret[i];\n      n /= i;\n    }\n  }\n  if (n != 1) ret[n] = 1;\n  return ret;\n}"
  '素因数分解(約数の個数) O(√n)  ':
    'prefix': 'Divisor'
    'body': "/*\n・素因数分解\n  > O(√n)\n[使用例] map<ll,int> mp = prime_factor(105);\n[応用例] (mpの各要素のsecond)+1を掛け合わせると, nの約数の個数\n*/\n\nmap<ll,int> prime_factor(ll n) {\n  map<ll,int> ret;\n  for (ll i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      ++ret[i];\n      n /= i;\n    }\n  }\n  if (n != 1) ret[n] = 1;\n  return ret;\n}"
  '素因数分解(約数の個数) O(√n)   ':
    'prefix': 'Yakusuu'
    'body': "/*\n・素因数分解\n  > O(√n)\n[使用例] map<ll,int> mp = prime_factor(105);\n[応用例] (mpの各要素のsecond)+1を掛け合わせると, nの約数の個数\n*/\n\nmap<ll,int> prime_factor(ll n) {\n  map<ll,int> ret;\n  for (ll i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      ++ret[i];\n      n /= i;\n    }\n  }\n  if (n != 1) ret[n] = 1;\n  return ret;\n}"

  '約数列挙 O(√n)':
    'prefix': 'Math     '
    'body': "/*\n・約数列挙\n  > O(√n)\n[使用例] vl div = divisor(105);\n[備考] 整列されていない\n*/\n\nvl divisor(ll n) {\n  vl ret;\n  for(ll i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      ret.PB(i);\n      if (i * i != n) ret.PB(n/i);\n    }\n  }\n  //SORT(ret);\n  return ret;\n}"
  '約数列挙 O(√n) ':
    'prefix': 'Divisor '
    'body': "/*\n・約数列挙\n  > O(√n)\n[使用例] vl div = divisor(105);\n[備考] 整列されていない\n*/\n\nvl divisor(ll n) {\n  vl ret;\n  for(ll i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      ret.PB(i);\n      if (i * i != n) ret.PB(n/i);\n    }\n  }\n  //SORT(ret);\n  return ret;\n}"
  '約数列挙 O(√n)  ':
    'prefix': 'Prime  '
    'body': "/*\n・約数列挙\n  > O(√n)\n[使用例] vl div = divisor(105);\n[備考] 整列されていない\n*/\n\nvl divisor(ll n) {\n  vl ret;\n  for(ll i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      ret.PB(i);\n      if (i * i != n) ret.PB(n/i);\n    }\n  }\n  //SORT(ret);\n  return ret;\n}"
  '約数列挙 O(√n)   ':
    'prefix': 'Yakusuu '
    'body': "/*\n・約数列挙\n  > O(√n)\n[使用例] vl div = divisor(105);\n[備考] 整列されていない\n*/\n\nvl divisor(ll n) {\n  vl ret;\n  for(ll i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      ret.PB(i);\n      if (i * i != n) ret.PB(n/i);\n    }\n  }\n  //SORT(ret);\n  return ret;\n}"

      # Mod
  '剰余系における演算':
    'prefix': 'ModInt'
    'body': "/*\n・ModInt\n[備考] Mod演算のための構造体\n[使用例]\nmodint M;                   // 剰余系MOD(1e9+7)における演算ができる\nModInt<mod> N;              // 剰余系modにおける演算ができる\n*/\n\ntemplate< int MODULO > struct ModInt {\n  using uint32 = uint_fast32_t;\n  using uint64 = uint_fast64_t;\n  uint64 x; ModInt() : x(0) {}\n  ModInt(uint64 y) : x(set(y % MODULO + MODULO)) {}\n  static uint64 set(const uint64 &y) { return (y < MODULO) ? y : y - MODULO; }\n  static ModInt make(const uint64 &y) { ModInt ret = y; return ret; }\n  ModInt operator+(const ModInt &m) const { return make(set(x + m.x)); }\n  ModInt operator-(const ModInt &m) const { return make(set(x + MODULO - m.x)); }\n  ModInt operator*(const ModInt &m) const { return make(x * m.x % MODULO); }\n  ModInt operator/(const ModInt &m) const { return make(x) * ~make(m.x); }\n  ModInt &operator+=(const ModInt &m) { return *this = *this + m; }\n  ModInt &operator-=(const ModInt &m) { return *this = *this - m; }\n  ModInt &operator*=(const ModInt &m) { return *this = *this * m; }\n  ModInt &operator/=(const ModInt &m) { return *this = *this / m; }\n  ModInt &operator^=(const uint64 &y) { return *this = *this ^ y; }\n  ModInt operator~ () const { return *this ^ (MODULO - 2); }\n  ModInt operator- () const { return make(set(MODULO - x)); }\n  ModInt operator! () const { init(uint32(*this)); return fact[uint32(*this)]; }\n  ModInt operator& () const { init(uint32(*this)); return finv[uint32(*this)]; }\n  ModInt operator++() { return *this = make(set(x + 1)); }\n  ModInt operator--() { return *this = make(set(x + MODULO - 1)); }\n  bool operator==(const ModInt &m) const { return x == m.x; }\n  bool operator!=(const ModInt &m) const { return x != m.x; }\n  bool operator< (const ModInt &m) const { return x <  m.x; }\n  bool operator<=(const ModInt &m) const { return x <= m.x; }\n  bool operator> (const ModInt &m) const { return x >  m.x; }\n  bool operator>=(const ModInt &m) const { return x >= m.x; }\n  explicit operator   bool() const { return x; }\n  explicit operator uint64() const { return x; }\n  ModInt operator^(uint64 y) const {\n    uint64 t = x, u = 1;\n    while (y) { if (y & 1) (u *= t) %= MODULO; (t *= t) %= MODULO; y >>= 1; }\n    return make(u);\n  }\n  friend ostream &operator<<(ostream &os, const ModInt< MODULO > &m) { return os << m.x; }\n  friend istream &operator>>(istream &is, ModInt< MODULO > &m) { uint64 y; is >> y; m = make(y); return is; }\n  static vector< ModInt > fact, finv, invs;\n  static void init(uint32 n) {\n    uint32 m = fact.size();\n    if (n < m) return;\n    fact.resize(n + 1, 1);\n    finv.resize(n + 1, 1);\n    invs.resize(n + 1, 1);\n    if (m == 0) m = 1;\n    for (uint32 i = m; i <= n; ++i) fact[i] = fact[i - 1] * ModInt(i);\n    finv[n] = ModInt(1) / fact[n];\n    for (uint32 i = n; i >= m; --i) finv[i - 1] = finv[i] * make(i);\n    for (uint32 i = m; i <= n; ++i) invs[i] = finv[i] * fact[i - 1];\n  }\n  static ModInt C(uint64 n, uint64 r) {\n    if (r == 0) return make(1);\n    if (r <  0) return make(0);\n    if (n <  0) return make(r & 1 ? MODULO - 1 : 1) * C(-n + r - 1, r);\n    if (n == 0 || n < r) return make(0);\n    init(n);\n    return fact[n] * finv[n - r] * finv[r];\n  }\n  static ModInt P(uint64 n, uint64 r) {\n    if (n < r || r < 0) return make(0);\n    init(n);\n    return fact[n] * finv[n - r];\n  }\n  static ModInt H(uint64 n, uint64 r) {\n    if (n < 0 || r < 0) return make(0);\n    if (!n && !r) return make(1);\n    init(n + r - 1);\n    return C(n + r - 1, r);\n  }\n  static ModInt montmort(uint32 n) {\n    ModInt res;\n    init(n);\n    for (uint32 k = 2; k <= n; ++k) {\n      if (k & 1) res -= finv[k];\n      else res += finv[k];\n    }\n    return res *= fact[n];\n  }\n  static ModInt LagrangePolynomial(vector<ModInt> &y, ModInt t) {\n    uint32 n = y.size() - 1;\n    if (t.x <= n) return y[t.x];\n    init(n + 1);\n    ModInt res, num(1);\n    for (uint32 i = 0; i <= n; ++i) num *= t - make(i);\n    for (uint32 i = 0; i <= n; ++i) {\n      ModInt tmp = y[i] * num / (t - make(i)) * finv[i] * finv[n - i];\n      if ((n - i) & 1) res -= tmp;\n      else res += tmp;\n    }\n    return res;\n  }\n};\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::fact = vector<ModInt< MODULO >>();\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::finv = vector<ModInt< MODULO >>();\ntemplate< int MODULO >\nvector<ModInt< MODULO >> ModInt< MODULO >::invs = vector<ModInt< MODULO >>();\nusing modint = ModInt< MOD >;"

      # Matrix
  '行列演算':
    'prefix': 'Matrix'
    'body': "/*\n・行列演算\n[使用例]\nMatrix<ll> mat(n,m);      // n行m列の行列を定義\nmat[i][j];                // i行j列目の要素を取得\nmat.determinant();        // matの行列式を計算\nmat ^= k;                 // matのk乗を計算\n*/\n\ntemplate< class T > struct Matrix {\n  vector< vector< T > > A;\n  Matrix() {}\n  Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}\n  Matrix(size_t n) : A(n, vector< T >(n, 0)) {};\n  size_t height() const { return (A.size()); }\n  size_t  width() const { return (A[0].size()); }\n  inline const vector< T > &operator[](int k) const { return (A.at(k)); }\n  inline       vector< T > &operator[](int k)       { return (A.at(k)); }\n  static Matrix I(size_t n) {\n    Matrix mat(n);\n    for (int i = 0; i < n; ++i) mat[i][i] = 1;\n    return (mat);\n  }\n  Matrix &operator+=(const Matrix &B) {\n    size_t n = height(), m = width();\n    assert(n == B.height() && m == B.width());\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j)\n        (*this)[i][j] += B[i][j];\n    return (*this);\n  }\n  Matrix &operator-=(const Matrix &B) {\n    size_t n = height(), m = width();\n    assert(n == B.height() && m == B.width());\n    for(int i = 0; i < n; i++)\n      for(int j = 0; j < m; j++)\n        (*this)[i][j] -= B[i][j];\n    return (*this);\n  }\n  Matrix &operator*=(const Matrix &B) {\n    size_t n = height(), m = B.width(), p = width();\n    assert(p == B.height());\n    vector< vector< T > > C(n, vector< T >(m, 0));\n    for(int i = 0; i < n; i++)\n      for(int j = 0; j < m; j++)\n        for(int k = 0; k < p; k++)\n          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);\n    A.swap(C);\n    return (*this);\n  }\n  Matrix &operator^=(long long k) {\n    Matrix B = Matrix::I(height());\n    while (k > 0) {\n      if (k & 1) B *= *this;\n      *this *= *this;\n      k >>= 1LL;\n    }\n    A.swap(B.A);\n    return (*this);\n  }\n  Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }\n  Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }\n  Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }\n  Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }\n  friend ostream &operator<<(ostream &os, Matrix &p) {\n    size_t n = p.height(), m = p.width();\n    for (int i = 0; i < n; i++) {\n      os << \"[\";\n      for (int j = 0; j < m; j++) {\n        os << p[i][j] << (j + 1 == m ? \"]\\\\n\" : \",\");\n      }\n    }\n    return (os);\n  }\n  T determinant() {\n    Matrix B(*this);\n    assert(width() == height());\n    T ret = 1;\n    for (int i = 0; i < width(); i++) {\n      int idx = -1;\n      for (int j = i; j < width(); j++) if (B[j][i] != 0) idx = j;\n      if (idx == -1) return (0);\n      if (i != idx) { ret *= -1; swap(B[i], B[idx]); }\n      ret *= B[i][i];\n      T vv = B[i][i];\n      for (int j = 0; j < width(); j++) B[i][j] /= vv;\n      for (int j = i + 1; j < width(); j++) {\n        T a = B[j][i];\n        for (int k = 0; k < width(); k++) B[j][k] -= B[i][k] * a;\n      }\n    }\n    return (ret);\n  }\n};"

  # Multiprecision
  '多倍長整数/浮動小数点数':
    'prefix': 'Multiprecision'
    'body': "/*\n・多倍長整数 Bint\n[使用例] Bint num;     // 任意精度の符号あり多倍長整数\nhttps://boostjp.github.io/tips/multiprec-int.html\n・多倍長浮動小数点数 Bfloat\n[使用例] Bfloat32 f;   // 仮数部が32bitの符号あり浮動小数点数\nhttps://boostjp.github.io/tips/multiprec-float.html\n*/\n\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing Bint = boost::multiprecision::cpp_int;\nusing Bfloat32 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32> >;\nusing Bfloat1024 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<1024> >;"
  '多倍長整数/浮動小数点数 ':
    'prefix': 'Tabaichou'
    'body': "/*\n・多倍長整数 Bint\n[使用例] Bint num;     // 任意精度の符号あり多倍長整数\nhttps://boostjp.github.io/tips/multiprec-int.html\n・多倍長浮動小数点数 Bfloat\n[使用例] Bfloat32 f;   // 仮数部が32bitの符号あり浮動小数点数\nhttps://boostjp.github.io/tips/multiprec-float.html\n*/\n\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing Bint = boost::multiprecision::cpp_int;\nusing Bfloat32 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32> >;\nusing Bfloat1024 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<1024> >;"
  '多倍長整数/浮動小数点数  ':
    'prefix': 'Bint/Bfloat'
    'body': "/*\n・多倍長整数 Bint\n[使用例] Bint num;     // 任意精度の符号あり多倍長整数\nhttps://boostjp.github.io/tips/multiprec-int.html\n・多倍長浮動小数点数 Bfloat\n[使用例] Bfloat32 f;   // 仮数部が32bitの符号あり浮動小数点数\nhttps://boostjp.github.io/tips/multiprec-float.html\n*/\n\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing Bint = boost::multiprecision::cpp_int;\nusing Bfloat32 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32> >;\nusing Bfloat1024 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<1024> >;"

  # UnionFind
  'UnionFind木 O(α(n))':
    'prefix': 'UnionFind'
    'body': "/*\n・UnionFind木\n  > O(α(n))\n[使用例]\nUnionFind uf(n);    // 頂点数nのUF木を宣言\nuf.unite(a,b);      // 点a,b([0,n))が同じ集合に属する (すでに同じだったらfalseを返す)\nbool isSameGroup = uf.same(a,b);  // 点a,bが同じ集合に属するか確認\ncout << uf.find(a) << endl;       // 点aが属する集合を求める\ncout << uf.size(a) << endl;       // 点aが属する集合の要素の数を求める\n*/\n\nstruct UnionFind {\n  vector<int> parent;\n  int __size;\n  UnionFind(int size_) : parent(size_, -1), __size(size_) {}\n  bool unite(int x,int y) {\n    if ((x=find(x)) != (y=find(y))) {\n      if (parent[y] < parent[x]) swap(x,y);\n      parent[x] += parent[y];\n      parent[y] = x;\n      __size--;\n      return true;\n    }\n    return false;\n  }\n  bool same(int x,int y){return find(x)==find(y);}\n  int find(int x){return parent[x] < 0 ? x : parent[x] = find(parent[x]);}\n  int size(int x){return -parent[find(x)];}\n  int size(){return __size;}\n};"
  '重み付きUnionFind木 O(α(n))':
    'prefix': 'UnionFind_Weight'
    'body': "/*\n・重み付きUnionFind木\n  > O(α(n))\n[使用例]\nUnionFind_Weight uf(n);      // 頂点数nの重み付きUF木を宣言\nuf.unite(a,b,w);              // 点a,b([0,n))が同じ集合に属し, それらの間の重みがwである (すでに同じだったらfalseを返す)\nbool isSameGroup = uf.same(a,b);    // 点a,bが同じ集合に属するか確認\ncout << uf.find(a) << endl;         // 点aが属する集合を求める\ncout << uf.diff(a,b) << endl;       // 点a,bの間の重みを求める\n*/\n\ntemplate<typename T> struct UnionFind_Weight {\n  vector<int> parent;\n  vector<int> rank;\n  vector<T> diff_weight;\n  UnionFind_Weight(int n = 1, T SUM_UNITY = 0) { init(n, SUM_UNITY); }\n  void init(int n = 1, T SUM_UNITY = 0) {\n    parent.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (int i = 0; i < n; ++i) parent[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n  int find(int x) {\n    if (parent[x] == x) return x;\n    int ret = find(parent[x]);\n    diff_weight[x] += diff_weight[parent[x]];\n    return parent[x] = ret;\n  }\n  bool unite(int x, int y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    parent[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n  T weight(int x) { find(x); return diff_weight[x]; }\n  T diff(int x, int y) { return weight(y) - weight(x); }\n  bool same(int x, int y) { return find(x) == find(y); }\n};"
  '重み付きUnionFind木 O(α(n)) ':
    'prefix': 'OmomitukiUnionFind'
    'body': "/*\n・重み付きUnionFind木\n  > O(α(n))\n[使用例]\nUnionFind_Weight uf(n);      // 頂点数nの重み付きUF木を宣言\nuf.unite(a,b,w);              // 点a,b([0,n))が同じ集合に属し, それらの間の重みがwである (すでに同じだったらfalseを返す)\nbool isSameGroup = uf.same(a,b);    // 点a,bが同じ集合に属するか確認\ncout << uf.find(a) << endl;         // 点aが属する集合を求める\ncout << uf.diff(a,b) << endl;       // 点a,bの間の重みを求める\n*/\n\ntemplate<typename T> struct UnionFind_Weight {\n  vector<int> parent;\n  vector<int> rank;\n  vector<T> diff_weight;\n  UnionFind_Weight(int n = 1, T SUM_UNITY = 0) { init(n, SUM_UNITY); }\n  void init(int n = 1, T SUM_UNITY = 0) {\n    parent.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (int i = 0; i < n; ++i) parent[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n  int find(int x) {\n    if (parent[x] == x) return x;\n    int ret = find(parent[x]);\n    diff_weight[x] += diff_weight[parent[x]];\n    return parent[x] = ret;\n  }\n  bool unite(int x, int y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    parent[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n  T weight(int x) { find(x); return diff_weight[x]; }\n  T diff(int x, int y) { return weight(y) - weight(x); }\n  bool same(int x, int y) { return find(x) == find(y); }\n};"

  # Graph
  'グラフの宣言':
    'prefix': 'Graph'
    'body': "/*\n・グラフ\n  > Dijkstra\n  > BellmanFord\n  > WarshallFloyd\n  > Kruskal\n[応用] 単一終点最短路問題は, すべての有向辺を逆向きに張り替えると, 単一始点最短路問題に帰着できる.\n[使用例]\nGraph<int> g(N);              // 頂点数N, 重さの型がintのグラフを宣言\nadd_edge(g,a,b,c);            // グラフgに, aからbへの重さcの無向辺を追加\nadd_arc(g,a,b,c);             // グラフgに, aからbへの重さcの有向辺を追加\nadd_to_edges(edges,a,b,c);    // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\n*/\n\ntemplate<typename T> struct Edge {\n  int from, to;\n  T weight;\n  Edge() : from(0), to(0), weight(0) {}\n  Edge(int f, int t, T w) : from(f), to(t), weight(w) {}\n};\ntemplate<typename T> using Edges = vector< Edge< T > >;\ntemplate<typename T> using Graph = vector< Edges< T > >;\ntemplate<typename T> void     add_edge(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from,to,w); g[to].emplace_back(to,from,w); }\ntemplate<typename T> void      add_arc(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from,to,w); }\ntemplate<typename T> void add_to_edges(Edges< T > &e, int from, int to, T w = 1) { e.emplace_back(from,to,w); }"
  'グラフの宣言 ':
    'prefix': 'add_arc/add_edge'
    'body': "/*\n・グラフ\n  > Dijkstra\n  > BellmanFord\n  > WarshallFloyd\n  > Kruskal\n[応用] 単一終点最短路問題は, すべての有向辺を逆向きに張り替えると, 単一始点最短路問題に帰着できる.\n[使用例]\nGraph<int> g(N);              // 頂点数N, 重さの型がintのグラフを宣言\nadd_edge(g,a,b,c);            // グラフgに, aからbへの重さcの無向辺を追加\nadd_arc(g,a,b,c);             // グラフgに, aからbへの重さcの有向辺を追加\nadd_to_edges(edges,a,b,c);    // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\n*/\n\ntemplate<typename T> struct Edge {\n  int from, to;\n  T weight;\n  Edge() : from(0), to(0), weight(0) {}\n  Edge(int f, int t, T w) : from(f), to(t), weight(w) {}\n};\ntemplate<typename T> using Edges = vector< Edge< T > >;\ntemplate<typename T> using Graph = vector< Edges< T > >;\ntemplate<typename T> void     add_edge(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from,to,w); g[to].emplace_back(to,from,w); }\ntemplate<typename T> void      add_arc(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from,to,w); }\ntemplate<typename T> void add_to_edges(Edges< T > &e, int from, int to, T w = 1) { e.emplace_back(from,to,w); }"

  'ワーシャルフロイド法 O(V^3)':
    'prefix': 'Graph '
    'body': "/*\n・ワーシャルフロイド法\n  > O(V^3) [V:頂点数] (WarshallFloyd())\n  > O(V^2) : 辺の追加 (add_edge_to_matrix())\n[備考] 全点間最短路を求めるアルゴリズム\n      負閉路が存在しているかの検出も可能\n        -> ある頂点vからv自身への最短路が負なが負閉路が存在\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nauto wf = WarshallFloyd(g);      // グラフgにおける全点間最短路\nadd_edge_to_matrix(wf,a,b,c);    // 隣接行列wfに, 始点a, 終点b, 重さcの辺を追加して, wfを更新\n*/\n\ntemplate<typename T> using Matrix = vector< vector< T > >;\ntemplate<typename T> Matrix< T > WarshallFloyd(Graph< T > &g) {\n  const auto INF = numeric_limits< T >::max()/10;\n  int vertex = g.size();\n  Matrix< T > dist(vertex, vector< T >(vertex, INF));\n  for (int i = 0; i < vertex; ++i) dist[i][i] = 0;\n  for (int i = 0; i < vertex; ++i) {\n    for (auto &e : g[i]) {\n      dist[e.from][e.to] = min(dist[e.from][e.to], e.weight);\n    }\n  }\n  for (int k = 0; k < vertex; ++k) {\n    for (int i = 0; i < vertex; ++i) {\n      for (int j = 0; j < vertex; ++j) {\n        if (dist[i][k] != INF && dist[k][j] != INF) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n  }\n  return dist;\n}\ntemplate<typename T> void add_edge_to_matrix(Matrix< T > &mat, int from, int to, T weight = 1) {\n  const auto INF = numeric_limits< T >::max()/10;\n  mat[from][to] = mat[to][from] = min(mat[from][to], weight);\n  int vertex = mat.size();\n  for (int k : {from, to}) {\n    for (int i = 0; i < vertex; ++i) {\n      for (int j = 0; j < vertex; ++j) {\n        if (mat[i][k] != INF && mat[k][j] != INF) {\n          mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n        }\n      }\n    }\n  }\n}"
  'ワーシャルフロイド法 O(V^3) ':
    'prefix': 'WarshallFloyd'
    'body': "/*\n・ワーシャルフロイド法\n  > O(V^3) [V:頂点数] (WarshallFloyd())\n  > O(V^2) : 辺の追加 (add_edge_to_matrix())\n[備考] 全点間最短路を求めるアルゴリズム\n      負閉路が存在しているかの検出も可能\n        -> ある頂点vからv自身への最短路が負なが負閉路が存在\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nauto wf = WarshallFloyd(g);      // グラフgにおける全点間最短路\nadd_edge_to_matrix(wf,a,b,c);    // 隣接行列wfに, 始点a, 終点b, 重さcの辺を追加して, wfを更新\n*/\n\ntemplate<typename T> using Matrix = vector< vector< T > >;\ntemplate<typename T> Matrix< T > WarshallFloyd(Graph< T > &g) {\n  const auto INF = numeric_limits< T >::max()/10;\n  int vertex = g.size();\n  Matrix< T > dist(vertex, vector< T >(vertex, INF));\n  for (int i = 0; i < vertex; ++i) dist[i][i] = 0;\n  for (int i = 0; i < vertex; ++i) {\n    for (auto &e : g[i]) {\n      dist[e.from][e.to] = min(dist[e.from][e.to], e.weight);\n    }\n  }\n  for (int k = 0; k < vertex; ++k) {\n    for (int i = 0; i < vertex; ++i) {\n      for (int j = 0; j < vertex; ++j) {\n        if (dist[i][k] != INF && dist[k][j] != INF) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n  }\n  return dist;\n}\ntemplate<typename T> void add_edge_to_matrix(Matrix< T > &mat, int from, int to, T weight = 1) {\n  const auto INF = numeric_limits< T >::max()/10;\n  mat[from][to] = mat[to][from] = min(mat[from][to], weight);\n  int vertex = mat.size();\n  for (int k : {from, to}) {\n    for (int i = 0; i < vertex; ++i) {\n      for (int j = 0; j < vertex; ++j) {\n        if (mat[i][k] != INF && mat[k][j] != INF) {\n          mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n        }\n      }\n    }\n  }\n}"

  'ダイクストラ法 O(ElogV)':
    'prefix': 'Graph  '
    'body': "/*\n・ダイクストラ法\n  > O(ElogV) [E:辺の数, V:頂点の数]\n[備考] 負辺の存在しないグラフに対する単一始点全点間最短路を求めるアルゴリズム\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nauto dij = Dijkstra(g,s);     // グラフgにおける, 始点sからの最短路\n*/\n\ntemplate<typename T> vector< T > Dijkstra(Graph<T> &g, int from) {\n  const auto INF = numeric_limits< T >::max()/10;\n  vector< T > dist(g.size(), INF);\n  dist[from] = 0;\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(dist[from], from);\n  while ( !que.empty() ) {\n    T weight; int idx;\n    tie(weight, idx) = que.top(); que.pop();\n    if (dist[idx] < weight) continue;\n    for (auto &e : g[idx]) {\n      auto next_weight = weight + e.weight;\n      if (dist[e.to] <= next_weight) continue;\n      dist[e.to] = next_weight;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}"
  'ダイクストラ法 O(ElogV) ':
    'prefix': 'Dijkstra'
    'body': "/*\n・ダイクストラ法\n  > O(ElogV) [E:辺の数, V:頂点の数]\n[備考] 負辺の存在しないグラフに対する単一始点全点間最短路を求めるアルゴリズム\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nauto dij = Dijkstra(g,s);     // グラフgにおける, 始点sからの最短路\n*/\n\ntemplate<typename T> vector< T > Dijkstra(Graph<T> &g, int from) {\n  const auto INF = numeric_limits< T >::max()/10;\n  vector< T > dist(g.size(), INF);\n  dist[from] = 0;\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(dist[from], from);\n  while ( !que.empty() ) {\n    T weight; int idx;\n    tie(weight, idx) = que.top(); que.pop();\n    if (dist[idx] < weight) continue;\n    for (auto &e : g[idx]) {\n      auto next_weight = weight + e.weight;\n      if (dist[e.to] <= next_weight) continue;\n      dist[e.to] = next_weight;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}"

  'ベルマンフォード法 O(EV)':
    'prefix': 'Graph   '
    'body': "/*\n・ベルマンフォード法\n  > O(EV) [E:辺の数, V:頂点の数]\n[備考] グラフ(負辺が存在してもよい)に対する単一始点全点間最短路を求めるアルゴリズム\n      負閉路が存在しているかの判定も可能 -> 存在していたら空列を返す\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nEdges<int> edges;                     // 全ての辺 (重さ: int)\nadd_to_edges(edges,a,b,c);            // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\nauto bf = BellmanFord(edges,V,s);     // 辺edges, 頂点数Vのグラフにおける, 始点sからの最短路\n*/\n\ntemplate<typename T> vector< T > BellmanFord(Edges< T > &edges, int vertex, int from) {\n  const auto INF = numeric_limits< T >::max()/10;\n  vector< T > dist(vertex, INF);\n  dist[from] = 0;\n  for (int i = 0; i < vertex - 1; ++i) {\n    for (auto &e : edges) {\n      if (dist[e.from] == INF) continue;\n      dist[e.to] = min(dist[e.to], dist[e.from] + e.weight);\n    }\n  }\n  for (auto &e : edges) {\n    if (dist[e.from] == INF) continue;\n    if (dist[e.from] + e.weight < dist[e.to]) return vector< T >();\n  }\n  return dist;\n}"
  'ベルマンフォード法 O(EV) ':
    'prefix': 'BellmanFord'
    'body': "/*\n・ベルマンフォード法\n  > O(EV) [E:辺の数, V:頂点の数]\n[備考] グラフ(負辺が存在してもよい)に対する単一始点全点間最短路を求めるアルゴリズム\n      負閉路が存在しているかの判定も可能 -> 存在していたら空列を返す\n[注意] 結果を足し合わせる際, INFの大きさに注意\n[使用例]\nEdges<int> edges;                     // 全ての辺 (重さ: int)\nadd_to_edges(edges,a,b,c);            // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\nauto bf = BellmanFord(edges,V,s);     // 辺edges, 頂点数Vのグラフにおける, 始点sからの最短路\n*/\n\ntemplate<typename T> vector< T > BellmanFord(Edges< T > &edges, int vertex, int from) {\n  const auto INF = numeric_limits< T >::max()/10;\n  vector< T > dist(vertex, INF);\n  dist[from] = 0;\n  for (int i = 0; i < vertex - 1; ++i) {\n    for (auto &e : edges) {\n      if (dist[e.from] == INF) continue;\n      dist[e.to] = min(dist[e.to], dist[e.from] + e.weight);\n    }\n  }\n  for (auto &e : edges) {\n    if (dist[e.from] == INF) continue;\n    if (dist[e.from] + e.weight < dist[e.to]) return vector< T >();\n  }\n  return dist;\n}"

  'クラスカル法 O(ElogV)':
    'prefix': 'Kruskal'
    'body': "/*\n・Kruskal法\n  > O(ElogV) [E:辺の数, V:頂点の数]\n[備考] 最小全域木を求めるアルゴリズム.\n      UnionFindで, 閉路を作らないように辺を重みが小さい順に加えていく.\n[注意] UnionFindを上で定義しておくこと.\n[使用例]\nEdges<int> edges;                     // 全ての辺 (重さ: int)\nadd_to_edges(edges,a,b,c);            // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\nauto k = Kruskal(edges,V);            // 辺edges, 頂点数Vのグラフにおける最小全域木の重さ\n*/\n\ntemplate<typename T> T Kruskal(Edges< T > &edges, int V) {\n  sort(begin(edges), end(edges), [](const Edge< T > &a, const Edge< T > &b) {\n    return (a.weight < b.weight);\n  });\n  UnionFind tree(V);\n  T ret = 0;\n  for (auto & e : edges) {\n    if (tree.unite(e.from, e.to)) ret += e.weight;\n  }\n  return ret;\n}"
  'クラスカル法 O(ElogV) ':
    'prefix': 'Saishouzenikigi'
    'body': "/*\n・Kruskal法\n  > O(ElogV) [E:辺の数, V:頂点の数]\n[備考] 最小全域木を求めるアルゴリズム.\n      UnionFindで, 閉路を作らないように辺を重みが小さい順に加えていく.\n[注意] UnionFindを上で定義しておくこと.\n[使用例]\nEdges<int> edges;                     // 全ての辺 (重さ: int)\nadd_to_edges(edges,a,b,c);            // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\nauto k = Kruskal(edges,V);            // 辺edges, 頂点数Vのグラフにおける最小全域木の重さ\n*/\n\ntemplate<typename T> T Kruskal(Edges< T > &edges, int V) {\n  sort(begin(edges), end(edges), [](const Edge< T > &a, const Edge< T > &b) {\n    return (a.weight < b.weight);\n  });\n  UnionFind tree(V);\n  T ret = 0;\n  for (auto & e : edges) {\n    if (tree.unite(e.from, e.to)) ret += e.weight;\n  }\n  return ret;\n}"
  'クラスカル法 O(ElogV)  ':
    'prefix': 'Tree'
    'body': "/*\n・Kruskal法\n  > O(ElogV) [E:辺の数, V:頂点の数]\n[備考] 最小全域木を求めるアルゴリズム.\n      UnionFindで, 閉路を作らないように辺を重みが小さい順に加えていく.\n[注意] UnionFindを上で定義しておくこと.\n[使用例]\nEdges<int> edges;                     // 全ての辺 (重さ: int)\nadd_to_edges(edges,a,b,c);            // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加\nauto k = Kruskal(edges,V);            // 辺edges, 頂点数Vのグラフにおける最小全域木の重さ\n*/\n\ntemplate<typename T> T Kruskal(Edges< T > &edges, int V) {\n  sort(begin(edges), end(edges), [](const Edge< T > &a, const Edge< T > &b) {\n    return (a.weight < b.weight);\n  });\n  UnionFind tree(V);\n  T ret = 0;\n  for (auto & e : edges) {\n    if (tree.unite(e.from, e.to)) ret += e.weight;\n  }\n  return ret;\n}"

  'トポロジカルソート O(E+V)':
    'prefix': 'Topological Sort'
    'body': "/*\n・トポロジカルソート\n  > O(E+V) [E:辺の数, V:頂点の数]\n[備考] グラフの位相的順序を求める.\n[使用例]\nvector<int> ts;             // トポロジカルソートの結果を格納するvector.\nTopologicalSort(g, ts);     // グラフgのトポロジカルソートの結果をtsに格納. 返り値はトポロジカルソート可能か否か.\n*/\n\ntemplate<typename T> bool TopologicalSort(const Graph<T> &g, vector<int> &order) {\n  int V = g.size();\n  vector<int> color(V);\n  function<bool(int)> visit = [&](int v) {\n    color[v] = 1;\n    for (auto& e: g[v]) {\n      if (color[e.to] == 2) continue;\n      if (color[e.to] == 1) return false;\n      if (!visit(e.to)) return false;\n    }\n    order.push_back(v); color[v] = 2;\n    return true;\n  };\n  for (int i = 0; i < V; ++i) if (!color[i] && !visit(i)) return false;\n  reverse(order.begin(), order.end());\n  return true;\n}"

  '二部グラフの判定 O(E+V)':
    'prefix': 'Bipartite Graph Check'
    'body': "/*\n・二部グラフの判定\n  > O(E+V) [E:辺の数, V:頂点の数]\n[備考] 二部グラフならTrueを返す.\n[使用例] isBipartiteGraph(g);\n[その他] 二部グラフだった際に, 片方の集合の大きさが知りたい場合は, return retを削除して, intを返すようにする.\n        その場合は, 二部グラフならばその集合の大きさを, そうでない場合は-1を返す.\n*/\n\ntemplate <typename T> bool isBipartiteGraph(const Graph<T> &g) {\n  int V = g.size();\n  vector<int> color(V, 0);\n  bool ret = true;\n  function<void(int, int)> dfs = [&](int i, int clr) {\n    if (color[i] != 0) return;\n    color[i] = clr;\n    for (auto& e: g[i]) {\n      if (color[e.to] == 0) dfs(e.to, -clr);\n      else if (color[e.to] == clr) ret = false;\n    }\n  };\n  dfs(0, 1);\n  return ret;\n  int cnt = 0;\n  for (auto& e: color) if (e == 1) ++cnt;\n  return ret ? -1 : cnt;\n}"
  '二部グラフの判定 O(E+V) ':
    'prefix': 'Nibugurahu'
    'body': "/*\n・二部グラフの判定\n  > O(E+V) [E:辺の数, V:頂点の数]\n[備考] 二部グラフならTrueを返す.\n[使用例] isBipartiteGraph(g);\n[その他] 二部グラフだった際に, 片方の集合の大きさが知りたい場合は, return retを削除して, intを返すようにする.\n        その場合は, 二部グラフならばその集合の大きさを, そうでない場合は-1を返す.\n*/\n\ntemplate <typename T> bool isBipartiteGraph(const Graph<T> &g) {\n  int V = g.size();\n  vector<int> color(V, 0);\n  bool ret = true;\n  function<void(int, int)> dfs = [&](int i, int clr) {\n    if (color[i] != 0) return;\n    color[i] = clr;\n    for (auto& e: g[i]) {\n      if (color[e.to] == 0) dfs(e.to, -clr);\n      else if (color[e.to] == clr) ret = false;\n    }\n  };\n  dfs(0, 1);\n  return ret;\n  int cnt = 0;\n  for (auto& e: color) if (e == 1) ++cnt;\n  return ret ? -1 : cnt;\n}"

  # Maximum Flow
  'Dinic法 O(EV^2)':
    'prefix': 'Dinic'
    'body': "/*\n・Dinic法\n  > O(EV^2) [E:辺の数, V:頂点の数]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nDinic<int> dnc(N);                // 頂点数Nのグラフを用意.\ndnc.add_edge(from, to, cap);      // 頂点fromから頂点toへ容量capの有向辺を足す.\ndnc.max_flow(s, t);               //\n*/\n\ntemplate<typename T> struct Dinic {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  const T INF;\n  vector< vector< edge > > graph;\n  vector< T > min_cost;\n  vector< int > iter;\n\n  Dinic(int n) : INF(numeric_limits< T >::max()) {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].push_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t) {\n    min_cost.assign(graph.size(), -1);\n    queue<int> que;\n    min_cost[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for (auto &e : graph[p]) {\n        if (e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return (flow);\n    for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    while (bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      T f = 0;\n      while ((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n};"
  'Dinic法 O(EV^2) ':
    'prefix': 'Maximum Flow'
    'body': "/*\n・Dinic法\n  > O(EV^2) [E:辺の数, V:頂点の数]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nDinic<int> dnc(N);                // 頂点数Nのグラフを用意.\ndnc.add_edge(from, to, cap);      // 頂点fromから頂点toへ容量capの有向辺を足す.\ndnc.max_flow(s, t);               //\n*/\n\ntemplate<typename T> struct Dinic {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  const T INF;\n  vector< vector< edge > > graph;\n  vector< T > min_cost;\n  vector< int > iter;\n\n  Dinic(int n) : INF(numeric_limits< T >::max()) {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].push_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t) {\n    min_cost.assign(graph.size(), -1);\n    queue<int> que;\n    min_cost[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for (auto &e : graph[p]) {\n        if (e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return (flow);\n    for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    while (bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      T f = 0;\n      while ((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n};"
  'Dinic法 O(EV^2)  ':
    'prefix': 'Flow'
    'body': "/*\n・Dinic法\n  > O(EV^2) [E:辺の数, V:頂点の数]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nDinic<int> dnc(N);                // 頂点数Nのグラフを用意.\ndnc.add_edge(from, to, cap);      // 頂点fromから頂点toへ容量capの有向辺を足す.\ndnc.max_flow(s, t);               //\n*/\n\ntemplate<typename T> struct Dinic {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  const T INF;\n  vector< vector< edge > > graph;\n  vector< T > min_cost;\n  vector< int > iter;\n\n  Dinic(int n) : INF(numeric_limits< T >::max()) {\n    graph.resize(n);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].push_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  bool bfs(int s, int t) {\n    min_cost.assign(graph.size(), -1);\n    queue<int> que;\n    min_cost[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int p = que.front();\n      que.pop();\n      for (auto &e : graph[p]) {\n        if (e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return (min_cost[t] != -1);\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return (flow);\n    for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return (d);\n        }\n      }\n    }\n    return (0);\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    while (bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      T f = 0;\n      while ((f = dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n    return (flow);\n  }\n};"
  'Ford-Fulkerson法 O(EF)':
    'prefix': 'FordFulkerson'
    'body': "/*\n・Ford-Fulkerson法\n  > O(EF) [E:辺の数, F:最大フロー]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nFordFulkerson<int> ff(N);         // 頂点数Nのグラフを用意.\nff.add_edge(from, to, cap);       // 頂点fromから頂点toへ容量capの有向辺を足す.\nff.max_flow(s, t);                // 頂点sから頂点tへ最大流を流す.\n*/\n\ntemplate<typename T> struct FordFulkerson {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n  const T INF;\n  int timestamp;\n\n  FordFulkerson(int n) : INF(numeric_limits< T >::max()), timestamp(0) {\n    graph.resize(n);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return flow;\n    used[idx] = timestamp;\n    for (auto &e : graph[idx]) {\n      if (e.cap > 0 && used[e.to] != timestamp) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    for (T f; (f = dfs(s, t, INF)) > 0; timestamp++) {\n      flow += f;\n    }\n    return flow;\n  }\n};"
  'Ford-Fulkerson法 O(EF) ':
    'prefix': 'Flow '
    'body': "/*\n・Ford-Fulkerson法\n  > O(EF) [E:辺の数, F:最大フロー]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nFordFulkerson<int> ff(N);         // 頂点数Nのグラフを用意.\nff.add_edge(from, to, cap);       // 頂点fromから頂点toへ容量capの有向辺を足す.\nff.max_flow(s, t);                // 頂点sから頂点tへ最大流を流す.\n*/\n\ntemplate<typename T> struct FordFulkerson {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n  const T INF;\n  int timestamp;\n\n  FordFulkerson(int n) : INF(numeric_limits< T >::max()), timestamp(0) {\n    graph.resize(n);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return flow;\n    used[idx] = timestamp;\n    for (auto &e : graph[idx]) {\n      if (e.cap > 0 && used[e.to] != timestamp) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    for (T f; (f = dfs(s, t, INF)) > 0; timestamp++) {\n      flow += f;\n    }\n    return flow;\n  }\n};"
  'Ford-Fulkerson法 O(EF)  ':
    'prefix': 'Maximum Flow '
    'body': "/*\n・Ford-Fulkerson法\n  > O(EF) [E:辺の数, F:最大フロー]\n[備考] 最大流を求めるアルゴリズム.\n      最大流は最小カットと一致する(最大フロー最小カット定理).\n      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.\n[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336\n[使用例]\nFordFulkerson<int> ff(N);         // 頂点数Nのグラフを用意.\nff.add_edge(from, to, cap);       // 頂点fromから頂点toへ容量capの有向辺を足す.\nff.max_flow(s, t);                // 頂点sから頂点tへ最大流を流す.\n*/\n\ntemplate<typename T> struct FordFulkerson {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n  const T INF;\n  int timestamp;\n\n  FordFulkerson(int n) : INF(numeric_limits< T >::max()), timestamp(0) {\n    graph.resize(n);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int from, int to, T cap) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[  to].size()});\n    graph[  to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1});\n  }\n\n  T dfs(int idx, const int t, T flow) {\n    if (idx == t) return flow;\n    used[idx] = timestamp;\n    for (auto &e : graph[idx]) {\n      if (e.cap > 0 && used[e.to] != timestamp) {\n        T d = dfs(e.to, t, min(flow, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    for (T f; (f = dfs(s, t, INF)) > 0; timestamp++) {\n      flow += f;\n    }\n    return flow;\n  }\n};"

  # Min Cost Flow
  '最小費用流 O(FElogV)':
    'prefix': 'Min Cost Flow'
    'body': "/*\n・最小費用流\n  > O(FElogV) [E:辺の数, V:頂点の数]\n[備考] 最小費用流を求めるアルゴリズム.\n[参考] 辺の数が多い場合は, O(UCV^2) [U:容量合計, C:費用合計] のアルゴリズムもある.\n      (http://www.prefield.com/algorithm/graph/primal_dual.html)\n[使用例]\nPrimal_Dual pd(N);                  // 頂点数Nのグラフを用意.\npd.add_edge(from, to, cap, cost);   // 頂点fromから頂点toへ, 容量cap, 単位コストcostの有向辺を用意.\npd.min_cost_flow(from, to, flow);   // 頂点fromから頂点toへ, 流量flowを流す際のコスト.\n*/\n\nstruct Primal_Dual {\n  const int INF = 1 << 30;\n  typedef pair< int, int > Pi;\n\n  struct edge {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost) {\n    graph[from].push_back((edge) {to, cap,  cost, (int) graph[to].size()});\n    graph[  to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while (f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n      while (!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if (min_cost[p.second] < p.first) continue;\n        for (int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if (e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if (min_cost[t] == INF) return -1;\n      for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};"
  '最小費用流 O(FElogV) ':
    'prefix': 'Flow  '
    'body': "/*\n・最小費用流\n  > O(FElogV) [E:辺の数, V:頂点の数]\n[備考] 最小費用流を求めるアルゴリズム.\n[参考] 辺の数が多い場合は, O(UCV^2) [U:容量合計, C:費用合計] のアルゴリズムもある.\n      (http://www.prefield.com/algorithm/graph/primal_dual.html)\n[使用例]\nPrimal_Dual pd(N);                  // 頂点数Nのグラフを用意.\npd.add_edge(from, to, cap, cost);   // 頂点fromから頂点toへ, 容量cap, 単位コストcostの有向辺を用意.\npd.min_cost_flow(from, to, flow);   // 頂点fromから頂点toへ, 流量flowを流す際のコスト.\n*/\n\nstruct Primal_Dual {\n  const int INF = 1 << 30;\n  typedef pair< int, int > Pi;\n\n  struct edge {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost) {\n    graph[from].push_back((edge) {to, cap,  cost, (int) graph[to].size()});\n    graph[  to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while (f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n      while (!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if (min_cost[p.second] < p.first) continue;\n        for (int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if (e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if (min_cost[t] == INF) return -1;\n      for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};"

  # Bipartite Matching
  '二部グラフの最大マッチング O(EV)':
    'prefix': 'Bipartite Matching'
    'body': "/*\n・二部グラフの最大マッチング\n  > O(EV) [E:辺の数, V:頂点の数]\n[備考] 最大流のアルゴリズムを用いて求める.\n[応用] 最大マッチングは, 最小点被覆と一致(Mとおく).\n      最大安定集合(最大独立集合)は, 最小辺被覆と(V-M)で一致.\n[参考] https://qiita.com/drken/items/e805e3f514acceb87602\n      https://qiita.com/drken/items/7f98315b56c95a6181a4\n[使用例]\nBipartite_Matching bip(N);      // 頂点数Nのグラフを用意.\nbip.add_edge(from, to);         // 頂点fromから頂点toへの有向辺を足す.\nbip.bipartite_matching();       // 最大マッチングを求める.\n*/\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n) : timestamp(0) {\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = timestamp;\n    for (int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if (alive[u] == 0) continue;\n      if (w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for (int i = 0; i < graph.size(); i++) {\n      if (alive[i] == 0) continue;\n      if (match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n};"
  '二部グラフの最大マッチング O(EV) ':
    'prefix': 'Nibugurahu '
    'body': "/*\n・二部グラフの最大マッチング\n  > O(EV) [E:辺の数, V:頂点の数]\n[備考] 最大流のアルゴリズムを用いて求める.\n[応用] 最大マッチングは, 最小点被覆と一致(Mとおく).\n      最大安定集合(最大独立集合)は, 最小辺被覆と(V-M)で一致.\n[参考] https://qiita.com/drken/items/e805e3f514acceb87602\n      https://qiita.com/drken/items/7f98315b56c95a6181a4\n[使用例]\nBipartite_Matching bip(N);      // 頂点数Nのグラフを用意.\nbip.add_edge(from, to);         // 頂点fromから頂点toへの有向辺を足す.\nbip.bipartite_matching();       // 最大マッチングを求める.\n*/\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n) : timestamp(0) {\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = timestamp;\n    for (int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if (alive[u] == 0) continue;\n      if (w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for (int i = 0; i < graph.size(); i++) {\n      if (alive[i] == 0) continue;\n      if (match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n};"
  '二部グラフの最大マッチング O(EV)  ':
    'prefix': 'Saidai Matching'
    'body': "/*\n・二部グラフの最大マッチング\n  > O(EV) [E:辺の数, V:頂点の数]\n[備考] 最大流のアルゴリズムを用いて求める.\n[応用] 最大マッチングは, 最小点被覆と一致(Mとおく).\n      最大安定集合(最大独立集合)は, 最小辺被覆と(V-M)で一致.\n[参考] https://qiita.com/drken/items/e805e3f514acceb87602\n      https://qiita.com/drken/items/7f98315b56c95a6181a4\n[使用例]\nBipartite_Matching bip(N);      // 頂点数Nのグラフを用意.\nbip.add_edge(from, to);         // 頂点fromから頂点toへの有向辺を足す.\nbip.bipartite_matching();       // 最大マッチングを求める.\n*/\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n) : timestamp(0) {\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = timestamp;\n    for (int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if (alive[u] == 0) continue;\n      if (w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for (int i = 0; i < graph.size(); i++) {\n      if (alive[i] == 0) continue;\n      if (match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n};"

  # Compression
  '座標圧縮':
    'prefix': 'Compression'
    'body': "/*\n・座標圧縮\n  > O(NlogN)\n[備考] 各数字の対応関係が欲しいときは, 引数にmapを入れてコメントアウトを外す.\n[使用例]\n1. 引数にmapを入れない場合\nvl com = compress(v);\n2. 引数にmapを入れる場合\nmap<ll,int> rev;\nvl com = compress(v, rev);\n*/\n\n// template<typename T> vector<T> compress(vector<T> ord, map<T,int> &rev) {\ntemplate<typename T> vector<T> compress(vector<T> ord) { map<T,int> rev;\n  vector<T> com = ord;\n  sort(com.begin(), com.end());\n  com.erase(unique(com.begin(), com.end()), com.end());\n  for (int i = 0; i < com.size(); ++i) rev[com[i]] = i;\n  vector<T> ret; for (auto& e : ord) ret.emplace_back(rev[e]);\n  return ret;\n}"
  '座標圧縮 ':
    'prefix': 'SegmentTree'
    'body': "/*\n・座標圧縮\n  > O(NlogN)\n[備考] 各数字の対応関係が欲しいときは, 引数にmapを入れてコメントアウトを外す.\n[使用例]\n1. 引数にmapを入れない場合\nvl com = compress(v);\n2. 引数にmapを入れる場合\nmap<ll,int> rev;\nvl com = compress(v, rev);\n*/\n\n// template<typename T> vector<T> compress(vector<T> ord, map<T,int> &rev) {\ntemplate<typename T> vector<T> compress(vector<T> ord) { map<T,int> rev;\n  vector<T> com = ord;\n  sort(com.begin(), com.end());\n  com.erase(unique(com.begin(), com.end()), com.end());\n  for (int i = 0; i < com.size(); ++i) rev[com[i]] = i;\n  vector<T> ret; for (auto& e : ord) ret.emplace_back(rev[e]);\n  return ret;\n}"
  '座標圧縮  ':
    'prefix': 'ZahyouAsshuku'
    'body': "/*\n・座標圧縮\n  > O(NlogN)\n[備考] 各数字の対応関係が欲しいときは, 引数にmapを入れてコメントアウトを外す.\n[使用例]\n1. 引数にmapを入れない場合\nvl com = compress(v);\n2. 引数にmapを入れる場合\nmap<ll,int> rev;\nvl com = compress(v, rev);\n*/\n\n// template<typename T> vector<T> compress(vector<T> ord, map<T,int> &rev) {\ntemplate<typename T> vector<T> compress(vector<T> ord) { map<T,int> rev;\n  vector<T> com = ord;\n  sort(com.begin(), com.end());\n  com.erase(unique(com.begin(), com.end()), com.end());\n  for (int i = 0; i < com.size(); ++i) rev[com[i]] = i;\n  vector<T> ret; for (auto& e : ord) ret.emplace_back(rev[e]);\n  return ret;\n}"

  # CumulativeSum
  '1次元累積和':
    'prefix': 'CumulativeSum'
    'body': "/*\n・1次元累積和\n  >     build O(N)\n  > add,query O(1)\n[応用例] 加減算をそれぞれXORにすると, 累積XOR\n[使用例]\nCumulativeSum<int> acc(N);      // 要素数Nの累積和用の配列\nacc.add(k, x);		// 要素kに値xを加える\nacc.build();      // 累積和を取る\nacc.query(k);  		// 閉区間[0, k]の和\nacc.query(l, r);  // 半開区間[l, r)の和\nacc[k];						// 要素kを取得\n*/\n\ntemplate<class T> struct CumulativeSum {\n  vector< T > data;\n  CumulativeSum(int sz, T init = 0) : data(sz, init) {};\n  void add(int k, T x) {\n    data[k] += x;\n    // data[k] ^= x;\n  }\n  void build() {\n    for (int i = 1; i < (int)data.size(); ++i) {\n      data[i] += data[i - 1];\n      // data[i] ^= data[i - 1];\n    }\n  }\n  T query(int k) {\n    if (k < 0) return 0;\n    return data[min(k, (int)data.size() - 1)];\n  }\n  T query(int l, int r) {\n    T ret = (data[min(r - 1, (int)data.size() - 1)]);\n    if (l > 0) ret -= (data[min(l - 1, (int)data.size() - 1)]);\n    // if (l > 0) ret ^= (data[min(l - 1, (int)data.size() - 1)]);\n    return ret;\n  }\n	T operator[](const int &k) {\n		return data[k];\n	}\n	void debug() {\n		for (int i = 0; i < (int)data.size(); ++i) cerr << data[i] << ' ';\n		cerr << ln;\n	}\n};"
  '1次元累積和 ':
    'prefix': 'imos'
    'body': "/*\n・1次元累積和\n  >     build O(N)\n  > add,query O(1)\n[応用例] 加減算をそれぞれXORにすると, 累積XOR\n[使用例]\nCumulativeSum<int> acc(N);      // 要素数Nの累積和用の配列\nacc.add(k, x);		// 要素kに値xを加える\nacc.build();      // 累積和を取る\nacc.query(k);  		// 閉区間[0, k]の和\nacc.query(l, r);  // 半開区間[l, r)の和\nacc[k];						// 要素kを取得\n*/\n\ntemplate<class T> struct CumulativeSum {\n  vector< T > data;\n  CumulativeSum(int sz, T init = 0) : data(sz, init) {};\n  void add(int k, T x) {\n    data[k] += x;\n    // data[k] ^= x;\n  }\n  void build() {\n    for (int i = 1; i < (int)data.size(); ++i) {\n      data[i] += data[i - 1];\n      // data[i] ^= data[i - 1];\n    }\n  }\n  T query(int k) {\n    if (k < 0) return 0;\n    return data[min(k, (int)data.size() - 1)];\n  }\n  T query(int l, int r) {\n    T ret = (data[min(r - 1, (int)data.size() - 1)]);\n    if (l > 0) ret -= (data[min(l - 1, (int)data.size() - 1)]);\n    // if (l > 0) ret ^= (data[min(l - 1, (int)data.size() - 1)]);\n    return ret;\n  }\n	T operator[](const int &k) {\n		return data[k];\n	}\n	void debug() {\n		for (int i = 0; i < (int)data.size(); ++i) cerr << data[i] << ' ';\n		cerr << ln;\n	}\n};"
  '1次元累積和  ':
    'prefix': 'Accumulate'
    'body': "/*\n・1次元累積和\n  >     build O(N)\n  > add,query O(1)\n[応用例] 加減算をそれぞれXORにすると, 累積XOR\n[使用例]\nCumulativeSum<int> acc(N);      // 要素数Nの累積和用の配列\nacc.add(k, x);		// 要素kに値xを加える\nacc.build();      // 累積和を取る\nacc.query(k);  		// 閉区間[0, k]の和\nacc.query(l, r);  // 半開区間[l, r)の和\nacc[k];						// 要素kを取得\n*/\n\ntemplate<class T> struct CumulativeSum {\n  vector< T > data;\n  CumulativeSum(int sz, T init = 0) : data(sz, init) {};\n  void add(int k, T x) {\n    data[k] += x;\n    // data[k] ^= x;\n  }\n  void build() {\n    for (int i = 1; i < (int)data.size(); ++i) {\n      data[i] += data[i - 1];\n      // data[i] ^= data[i - 1];\n    }\n  }\n  T query(int k) {\n    if (k < 0) return 0;\n    return data[min(k, (int)data.size() - 1)];\n  }\n  T query(int l, int r) {\n    T ret = (data[min(r - 1, (int)data.size() - 1)]);\n    if (l > 0) ret -= (data[min(l - 1, (int)data.size() - 1)]);\n    // if (l > 0) ret ^= (data[min(l - 1, (int)data.size() - 1)]);\n    return ret;\n  }\n	T operator[](const int &k) {\n		return data[k];\n	}\n	void debug() {\n		for (int i = 0; i < (int)data.size(); ++i) cerr << data[i] << ' ';\n		cerr << ln;\n	}\n};"
  '1次元累積和   ':
    'prefix': 'Ruisekiwaxor'
    'body': "/*\n・1次元累積和\n  >     build O(N)\n  > add,query O(1)\n[応用例] 加減算をそれぞれXORにすると, 累積XOR\n[使用例]\nCumulativeSum<int> acc(N);      // 要素数Nの累積和用の配列\nacc.add(k, x);		// 要素kに値xを加える\nacc.build();      // 累積和を取る\nacc.query(k);  		// 閉区間[0, k]の和\nacc.query(l, r);  // 半開区間[l, r)の和\nacc[k];						// 要素kを取得\n*/\n\ntemplate<class T> struct CumulativeSum {\n  vector< T > data;\n  CumulativeSum(int sz, T init = 0) : data(sz, init) {};\n  void add(int k, T x) {\n    data[k] += x;\n    // data[k] ^= x;\n  }\n  void build() {\n    for (int i = 1; i < (int)data.size(); ++i) {\n      data[i] += data[i - 1];\n      // data[i] ^= data[i - 1];\n    }\n  }\n  T query(int k) {\n    if (k < 0) return 0;\n    return data[min(k, (int)data.size() - 1)];\n  }\n  T query(int l, int r) {\n    T ret = (data[min(r - 1, (int)data.size() - 1)]);\n    if (l > 0) ret -= (data[min(l - 1, (int)data.size() - 1)]);\n    // if (l > 0) ret ^= (data[min(l - 1, (int)data.size() - 1)]);\n    return ret;\n  }\n	T operator[](const int &k) {\n		return data[k];\n	}\n	void debug() {\n		for (int i = 0; i < (int)data.size(); ++i) cerr << data[i] << ' ';\n		cerr << ln;\n	}\n};"

  '2次元累積和':
    'prefix': 'CumulativeSum2D'
    'body': "/*\n・2次元累積和\n  >     build O(WH)\n  > add,query O(1)\n[使用例]\nCumulativeSum2D<int> acc(M,N);  // acc[W+1][H+1]\nacc.add(L,R,x);     // 要素(L,R)に値xを加える\nacc.build();        // 累積和を取る\ncout << acc.query(a,b,c,d) << endl;   // [a,b]から(c,d)までの和\n*/\n\ntemplate<class T> struct CumulativeSum2D {\n  vector<vector<T>> data;\n  CumulativeSum2D(int W, int H) : data(W+1,vi(H+1,0)) {}\n  void add(int x, int y, int z) {\n    ++x, ++y;\n    if (x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n  void build() {\n    for(int i = 1; i < data.size(); ++i) {\n      for(int j = 1; j < data[i].size(); ++j) {\n        data[i][j] += data[i][j-1] + data[i-1][j] - data[i-1][j-1];\n      }\n    }\n  }\n  T query(int sx, int sy, int gx, int gy) {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};"
  '2次元累積和 ':
    'prefix': 'imos'
    'body': "/*\n・2次元累積和\n  >     build O(WH)\n  > add,query O(1)\n[使用例]\nCumulativeSum2D<int> acc(M,N);  // acc[W+1][H+1]\nacc.add(L,R,x);     // 要素(L,R)に値xを加える\nacc.build();        // 累積和を取る\ncout << acc.query(a,b,c,d) << endl;   // [a,b]から(c,d)までの和\n*/\n\ntemplate<class T> struct CumulativeSum2D {\n  vector<vector<T>> data;\n  CumulativeSum2D(int W, int H) : data(W+1,vi(H+1,0)) {}\n  void add(int x, int y, int z) {\n    ++x, ++y;\n    if (x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n  void build() {\n    for(int i = 1; i < data.size(); ++i) {\n      for(int j = 1; j < data[i].size(); ++j) {\n        data[i][j] += data[i][j-1] + data[i-1][j] - data[i-1][j-1];\n      }\n    }\n  }\n  T query(int sx, int sy, int gx, int gy) {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};"
  '2次元累積和  ':
    'prefix': 'Accumulate'
    'body': "/*\n・2次元累積和\n  >     build O(WH)\n  > add,query O(1)\n[使用例]\nCumulativeSum2D<int> acc(M,N);  // acc[W+1][H+1]\nacc.add(L,R,x);     // 要素(L,R)に値xを加える\nacc.build();        // 累積和を取る\ncout << acc.query(a,b,c,d) << endl;   // [a,b]から(c,d)までの和\n*/\n\ntemplate<class T> struct CumulativeSum2D {\n  vector<vector<T>> data;\n  CumulativeSum2D(int W, int H) : data(W+1,vi(H+1,0)) {}\n  void add(int x, int y, int z) {\n    ++x, ++y;\n    if (x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n  void build() {\n    for(int i = 1; i < data.size(); ++i) {\n      for(int j = 1; j < data[i].size(); ++j) {\n        data[i][j] += data[i][j-1] + data[i-1][j] - data[i-1][j-1];\n      }\n    }\n  }\n  T query(int sx, int sy, int gx, int gy) {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};"
  '2次元累積和   ':
    'prefix': 'Ruisekiwa'
    'body': "/*\n・2次元累積和\n  >     build O(WH)\n  > add,query O(1)\n[使用例]\nCumulativeSum2D<int> acc(M,N);  // acc[W+1][H+1]\nacc.add(L,R,x);     // 要素(L,R)に値xを加える\nacc.build();        // 累積和を取る\ncout << acc.query(a,b,c,d) << endl;   // [a,b]から(c,d)までの和\n*/\n\ntemplate<class T> struct CumulativeSum2D {\n  vector<vector<T>> data;\n  CumulativeSum2D(int W, int H) : data(W+1,vi(H+1,0)) {}\n  void add(int x, int y, int z) {\n    ++x, ++y;\n    if (x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n  void build() {\n    for(int i = 1; i < data.size(); ++i) {\n      for(int j = 1; j < data[i].size(); ++j) {\n        data[i][j] += data[i][j-1] + data[i-1][j] - data[i-1][j-1];\n      }\n    }\n  }\n  T query(int sx, int sy, int gx, int gy) {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};"

  # Conversion
  '文字列と整数同士の変換':
    'prefix': 'Conversion'
    'body': "/*\n・文字列と整数同士の変換\n[使用例]\ncout << toInt(\"222\") / 2 << endl;   // 111\ncout << toString(222)+2 << endl;    // 224\nll n = 9876; string t;\nntos(n,t);  // t = \"9876\"\nstring s = \"1234\"; ll m;\nston(s,m);  // m = 1234\n*/\n\ninline ll toInt(string s){ll v;istringstream sin(s);sin >> v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout << x;return sout.str();}\ntemplate<typename T> inline void ntos(const T &n,string &s){stringstream stream; stream << n; stream >> s;}\ntemplate<typename T> inline void ston(const string &s,T &n){stringstream stream(s); stream >> n;}"
  '文字列と整数同士の変換 ':
    'prefix': 'toString/toInt'
    'body': "/*\n・文字列と整数同士の変換\n[使用例]\ncout << toInt(\"222\") / 2 << endl;   // 111\ncout << toString(222)+2 << endl;    // 224\nll n = 9876; string t;\nntos(n,t);  // t = \"9876\"\nstring s = \"1234\"; ll m;\nston(s,m);  // m = 1234\n*/\n\ninline ll toInt(string s){ll v;istringstream sin(s);sin >> v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout << x;return sout.str();}\ntemplate<typename T> inline void ntos(const T &n,string &s){stringstream stream; stream << n; stream >> s;}\ntemplate<typename T> inline void ston(const string &s,T &n){stringstream stream(s); stream >> n;}"
  '文字列と整数同士の変換  ':
    'prefix': 'ston'
    'body': "/*\n・文字列と整数同士の変換\n[使用例]\ncout << toInt(\"222\") / 2 << endl;   // 111\ncout << toString(222)+2 << endl;    // 224\nll n = 9876; string t;\nntos(n,t);  // t = \"9876\"\nstring s = \"1234\"; ll m;\nston(s,m);  // m = 1234\n*/\n\ninline ll toInt(string s){ll v;istringstream sin(s);sin >> v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout << x;return sout.str();}\ntemplate<typename T> inline void ntos(const T &n,string &s){stringstream stream; stream << n; stream >> s;}\ntemplate<typename T> inline void ston(const string &s,T &n){stringstream stream(s); stream >> n;}"
  '文字列と整数同士の変換   ':
    'prefix': 'ntos'
    'body': "/*\n・文字列と整数同士の変換\n[使用例]\ncout << toInt(\"222\") / 2 << endl;   // 111\ncout << toString(222)+2 << endl;    // 224\nll n = 9876; string t;\nntos(n,t);  // t = \"9876\"\nstring s = \"1234\"; ll m;\nston(s,m);  // m = 1234\n*/\n\ninline ll toInt(string s){ll v;istringstream sin(s);sin >> v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout << x;return sout.str();}\ntemplate<typename T> inline void ntos(const T &n,string &s){stringstream stream; stream << n; stream >> s;}\ntemplate<typename T> inline void ston(const string &s,T &n){stringstream stream(s); stream >> n;}"

  # SegmentTree
  'セグメント木':
    'prefix': 'Data Structure'
    'body': "/*\n・セグメント木\n  >         build O(N)\n  > query, update O(logN)\n[備考] 結合律, 単位元を持つ二項演算を, 任意の区間に関してlogNで行うデータ構造\n[使用例]\nSegmentTree<int> seg_sum(N, [](int a, int b){ return a+b; }, 0 );       // 区間和\nSegmentTree<int> seg_min(N, [](int a, int b){ return min(a,b); }, INF); // 区間min\nseg_min.set(k,x);     // 要素kに値xを設定\nseg_min.build();      // 上のセグメントに値を設定\nseg_min.update(k,x);  // 要素kを値xに変更\nseg_min.add(k,x);     // 要素kに値xを加算\nseg_min.query(l,r);   // 区間[l,r)に対する二項演算の結果を返す\n*/\n\ntemplate<typename T> struct SegmentTree {\n\n  using F = function< T(T,T) >;\n\n  vector< T > seg;\n\n  int size;       // データの数以上の最小の2冪, 最下段のデータの個数\n  const F func;\n  const T M1;\n\n  SegmentTree(int n, const F f, const T &M) : func(f), M1(M) {\n    size = 1; while (size < n) size *= 2;\n    seg.resize(2 * size - 1, M1);\n  }\n\n  void set(int k, T x) {\n    seg[k + size - 1] = x;\n  }\n\n  void build() {\n    for (int i = size - 2; i >= 0; --i) {\n      // iの子は, (2*i+1, 2*i+2)\n      seg[i] = func(seg[2*i+1], seg[2*i+2]);\n    }\n  }\n\n  void update(int k, T x) {\n    // kをseg内の添字に対応させる <- (size - 1)を足す\n    k += size - 1;\n    seg[k] = x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      seg[k] = func(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n\n  void add(int k, T x) {\n    // kをseg内の添字に対応させる <- (size - 1)を足す\n    k += size - 1;\n    seg[k] += x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      seg[k] = func(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = size;\n    if (r <= a || l >= b) return M1;\n    if (l >= a && r <= b) return seg[k];\n    T f_l = query(a, b, 2*k+1, l, (l+r)/2);\n    T f_r = query(a, b, 2*k+2, (l+r)/2, r);\n    return func(f_l, f_r);\n  }\n\n  void debug() {\n    for (int i = 0; i < 2 * size - 1; ++i) {\n      cerr << seg[i] << \" \\\\n\"[i==2*size-2];\n    }\n  }\n\n};"
  'セグメント木 ':
    'prefix': 'SegmentTree'
    'body': "/*\n・セグメント木\n  >         build O(N)\n  > query, update O(logN)\n[備考] 結合律, 単位元を持つ二項演算を, 任意の区間に関してlogNで行うデータ構造\n[使用例]\nSegmentTree<int> seg_sum(N, [](int a, int b){ return a+b; }, 0 );       // 区間和\nSegmentTree<int> seg_min(N, [](int a, int b){ return min(a,b); }, INF); // 区間min\nseg_min.set(k,x);     // 要素kに値xを設定\nseg_min.build();      // 上のセグメントに値を設定\nseg_min.update(k,x);  // 要素kを値xに変更\nseg_min.add(k,x);     // 要素kに値xを加算\nseg_min.query(l,r);   // 区間[l,r)に対する二項演算の結果を返す\n*/\n\ntemplate<typename T> struct SegmentTree {\n\n  using F = function< T(T,T) >;\n\n  vector< T > seg;\n\n  int size;       // データの数以上の最小の2冪, 最下段のデータの個数\n  const F func;\n  const T M1;\n\n  SegmentTree(int n, const F f, const T &M) : func(f), M1(M) {\n    size = 1; while (size < n) size *= 2;\n    seg.resize(2 * size - 1, M1);\n  }\n\n  void set(int k, T x) {\n    seg[k + size - 1] = x;\n  }\n\n  void build() {\n    for (int i = size - 2; i >= 0; --i) {\n      // iの子は, (2*i+1, 2*i+2)\n      seg[i] = func(seg[2*i+1], seg[2*i+2]);\n    }\n  }\n\n  void update(int k, T x) {\n    // kをseg内の添字に対応させる <- (size - 1)を足す\n    k += size - 1;\n    seg[k] = x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      seg[k] = func(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n\n  void add(int k, T x) {\n    // kをseg内の添字に対応させる <- (size - 1)を足す\n    k += size - 1;\n    seg[k] += x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      seg[k] = func(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = size;\n    if (r <= a || l >= b) return M1;\n    if (l >= a && r <= b) return seg[k];\n    T f_l = query(a, b, 2*k+1, l, (l+r)/2);\n    T f_r = query(a, b, 2*k+2, (l+r)/2, r);\n    return func(f_l, f_r);\n  }\n\n  void debug() {\n    for (int i = 0; i < 2 * size - 1; ++i) {\n      cerr << seg[i] << \" \\\\n\"[i==2*size-2];\n    }\n  }\n\n};"
  '遅延評価セグメント木':
    'prefix': 'Data Structure '
    'body': "/*\n・遅延評価セグメント木\n	> query, update O(logN)\n[引数]\nLazySegmentTree<Monoid, OperatorMonoid> seg(sz, f, g, h, d1, d0, v, p);\n> sz : 要素数\n>  f : 要素と要素をマージする関数\n>  g : 要素に作用素を作用させる関数\n>  h : 作用素と作用素をマージする関数\n> d1 : 要素のモノイド\n> d0 : 作用素のモノイド\n>  v : 初期化用の配列\n>  p : 区間に対する操作が要素数に比例して変化する場合 ( p(a, b) = g(a, a, ..., a) [aはb個] )\n[備考]\n以下の3つの条件を満たすときに使える\n1. g(f(a, b), c) = f(g(a, c), g(b, c))\n( 1'. g(f(a, b), p(c, d)) = f(g(a, p(c, d / 2)), g(b, p(c, d / 2))) )\n2. g(g(a, b), c) = g(a, h(b, c))\n3. g(a, d0) = a\n[典型例]\n> 区間加算 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), plus<ll>(), plus<ll>(), 0, 0, vl(N,0), multiplies<ll>());\n> 区間加算 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, plus<ll>(), plus<ll>(), INFF, 0);\n> 区間更新 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, 0, INFF, vl(N,0), multiplies<ll>());\n> 区間更新 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, INFF, INFF);\n[使用例]\nseg.update(l, r, x);			// 半開区間[l, r)に作用素xを作用\nseg.query(l, r);					// 半開区間[l, r)に対する演算の結果\nseg[k];										// k番目の要素を取得\n*/\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid> struct LazySegmentTree {\n\n  typedef function< Monoid(Monoid, Monoid) > F;\n  typedef function< Monoid(Monoid, OperatorMonoid) > G;\n  typedef function< OperatorMonoid(OperatorMonoid, OperatorMonoid) > H;\n  typedef function< OperatorMonoid(OperatorMonoid, int) > P;\n\n  int sz;\n  F f;\n  G g;\n  H h;\n  P p;\n  Monoid d1;\n  OperatorMonoid d0;\n  vector< Monoid > dat;\n  vector< OperatorMonoid > laz;\n\n  LazySegmentTree(int n, F f, G g, H h, Monoid d1, OperatorMonoid d0,\n              vector< Monoid > v = vector< Monoid >(), P p = [] (OperatorMonoid a, int b) { return a; })\n              : f(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n    sz = 1; while (sz < n) sz <<= 1;\n    dat.assign(2 * sz - 1, d1);\n    laz.assign(2 * sz - 1, d0);\n    if (n == (int)v.size()) build(n, v);\n  }\n\n  void build(int n, vector<Monoid> &v) {\n    for (int i = 0; i < n; i++)\n      dat[i + sz - 1] = v[i];\n    for (int i = sz - 2; i >= 0; i--)\n      dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n\n  inline void eval(int len, int k) {\n    if (laz[k] == d0) return;\n    if (k * 2 + 1 < sz * 2 - 1) {\n      laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n      laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n    }\n    dat[k] = g(dat[k], p(laz[k], len));\n    laz[k] = d0;\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r) {\n    eval(r - l, k);\n    if(r <= a || b <= l) return dat[k];\n    if(a <= l && r <= b) {\n      laz[k] = h(laz[k], x);\n      return g(dat[k], p(laz[k], r - l));\n    }\n    return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n		    update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x) {\n    return update(a, b, x, 0, 0, sz);\n  }\n\n  Monoid query(int a, int b, int k, int l, int r) {\n    eval(r - l, k);\n    if (r <= a || b <= l) return d1;\n    if (a <= l && r <= b) return dat[k];\n    Monoid vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    Monoid vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n\n  Monoid query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n\n};"
  '遅延評価セグメント木 ':
    'prefix': 'SegmentTree '
    'body': "/*\n・遅延評価セグメント木\n	> query, update O(logN)\n[引数]\nLazySegmentTree<Monoid, OperatorMonoid> seg(sz, f, g, h, d1, d0, v, p);\n> sz : 要素数\n>  f : 要素と要素をマージする関数\n>  g : 要素に作用素を作用させる関数\n>  h : 作用素と作用素をマージする関数\n> d1 : 要素のモノイド\n> d0 : 作用素のモノイド\n>  v : 初期化用の配列\n>  p : 区間に対する操作が要素数に比例して変化する場合 ( p(a, b) = g(a, a, ..., a) [aはb個] )\n[備考]\n以下の3つの条件を満たすときに使える\n1. g(f(a, b), c) = f(g(a, c), g(b, c))\n( 1'. g(f(a, b), p(c, d)) = f(g(a, p(c, d / 2)), g(b, p(c, d / 2))) )\n2. g(g(a, b), c) = g(a, h(b, c))\n3. g(a, d0) = a\n[典型例]\n> 区間加算 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), plus<ll>(), plus<ll>(), 0, 0, vl(N,0), multiplies<ll>());\n> 区間加算 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, plus<ll>(), plus<ll>(), INFF, 0);\n> 区間更新 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, 0, INFF, vl(N,0), multiplies<ll>());\n> 区間更新 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, INFF, INFF);\n[使用例]\nseg.update(l, r, x);			// 半開区間[l, r)に作用素xを作用\nseg.query(l, r);					// 半開区間[l, r)に対する演算の結果\nseg[k];										// k番目の要素を取得\n*/\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid> struct LazySegmentTree {\n\n  typedef function< Monoid(Monoid, Monoid) > F;\n  typedef function< Monoid(Monoid, OperatorMonoid) > G;\n  typedef function< OperatorMonoid(OperatorMonoid, OperatorMonoid) > H;\n  typedef function< OperatorMonoid(OperatorMonoid, int) > P;\n\n  int sz;\n  F f;\n  G g;\n  H h;\n  P p;\n  Monoid d1;\n  OperatorMonoid d0;\n  vector< Monoid > dat;\n  vector< OperatorMonoid > laz;\n\n  LazySegmentTree(int n, F f, G g, H h, Monoid d1, OperatorMonoid d0,\n              vector< Monoid > v = vector< Monoid >(), P p = [] (OperatorMonoid a, int b) { return a; })\n              : f(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n    sz = 1; while (sz < n) sz <<= 1;\n    dat.assign(2 * sz - 1, d1);\n    laz.assign(2 * sz - 1, d0);\n    if (n == (int)v.size()) build(n, v);\n  }\n\n  void build(int n, vector<Monoid> &v) {\n    for (int i = 0; i < n; i++)\n      dat[i + sz - 1] = v[i];\n    for (int i = sz - 2; i >= 0; i--)\n      dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n\n  inline void eval(int len, int k) {\n    if (laz[k] == d0) return;\n    if (k * 2 + 1 < sz * 2 - 1) {\n      laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n      laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n    }\n    dat[k] = g(dat[k], p(laz[k], len));\n    laz[k] = d0;\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r) {\n    eval(r - l, k);\n    if(r <= a || b <= l) return dat[k];\n    if(a <= l && r <= b) {\n      laz[k] = h(laz[k], x);\n      return g(dat[k], p(laz[k], r - l));\n    }\n    return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n		    update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x) {\n    return update(a, b, x, 0, 0, sz);\n  }\n\n  Monoid query(int a, int b, int k, int l, int r) {\n    eval(r - l, k);\n    if (r <= a || b <= l) return d1;\n    if (a <= l && r <= b) return dat[k];\n    Monoid vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    Monoid vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n\n  Monoid query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n\n};"
  '遅延評価セグメント木  ':
    'prefix': 'LazySegmentTree'
    'body': "/*\n・遅延評価セグメント木\n	> query, update O(logN)\n[引数]\nLazySegmentTree<Monoid, OperatorMonoid> seg(sz, f, g, h, d1, d0, v, p);\n> sz : 要素数\n>  f : 要素と要素をマージする関数\n>  g : 要素に作用素を作用させる関数\n>  h : 作用素と作用素をマージする関数\n> d1 : 要素のモノイド\n> d0 : 作用素のモノイド\n>  v : 初期化用の配列\n>  p : 区間に対する操作が要素数に比例して変化する場合 ( p(a, b) = g(a, a, ..., a) [aはb個] )\n[備考]\n以下の3つの条件を満たすときに使える\n1. g(f(a, b), c) = f(g(a, c), g(b, c))\n( 1'. g(f(a, b), p(c, d)) = f(g(a, p(c, d / 2)), g(b, p(c, d / 2))) )\n2. g(g(a, b), c) = g(a, h(b, c))\n3. g(a, d0) = a\n[典型例]\n> 区間加算 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), plus<ll>(), plus<ll>(), 0, 0, vl(N,0), multiplies<ll>());\n> 区間加算 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, plus<ll>(), plus<ll>(), INFF, 0);\n> 区間更新 -> 区間和\nLazySegmentTree<ll> seg(N, plus<ll>(), [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, 0, INFF, vl(N,0), multiplies<ll>());\n> 区間更新 -> 区間最小\nLazySegmentTree<ll> seg(N, [](ll a,ll b){return min(a,b);}, [](ll a,ll b){return b;}, [](ll a,ll b){return b;}, INFF, INFF);\n[使用例]\nseg.update(l, r, x);			// 半開区間[l, r)に作用素xを作用\nseg.query(l, r);					// 半開区間[l, r)に対する演算の結果\nseg[k];										// k番目の要素を取得\n*/\n\ntemplate <typename Monoid, typename OperatorMonoid = Monoid> struct LazySegmentTree {\n\n  typedef function< Monoid(Monoid, Monoid) > F;\n  typedef function< Monoid(Monoid, OperatorMonoid) > G;\n  typedef function< OperatorMonoid(OperatorMonoid, OperatorMonoid) > H;\n  typedef function< OperatorMonoid(OperatorMonoid, int) > P;\n\n  int sz;\n  F f;\n  G g;\n  H h;\n  P p;\n  Monoid d1;\n  OperatorMonoid d0;\n  vector< Monoid > dat;\n  vector< OperatorMonoid > laz;\n\n  LazySegmentTree(int n, F f, G g, H h, Monoid d1, OperatorMonoid d0,\n              vector< Monoid > v = vector< Monoid >(), P p = [] (OperatorMonoid a, int b) { return a; })\n              : f(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n    sz = 1; while (sz < n) sz <<= 1;\n    dat.assign(2 * sz - 1, d1);\n    laz.assign(2 * sz - 1, d0);\n    if (n == (int)v.size()) build(n, v);\n  }\n\n  void build(int n, vector<Monoid> &v) {\n    for (int i = 0; i < n; i++)\n      dat[i + sz - 1] = v[i];\n    for (int i = sz - 2; i >= 0; i--)\n      dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n\n  inline void eval(int len, int k) {\n    if (laz[k] == d0) return;\n    if (k * 2 + 1 < sz * 2 - 1) {\n      laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n      laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n    }\n    dat[k] = g(dat[k], p(laz[k], len));\n    laz[k] = d0;\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r) {\n    eval(r - l, k);\n    if(r <= a || b <= l) return dat[k];\n    if(a <= l && r <= b) {\n      laz[k] = h(laz[k], x);\n      return g(dat[k], p(laz[k], r - l));\n    }\n    return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n		    update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n  }\n\n  Monoid update(int a, int b, OperatorMonoid x) {\n    return update(a, b, x, 0, 0, sz);\n  }\n\n  Monoid query(int a, int b, int k, int l, int r) {\n    eval(r - l, k);\n    if (r <= a || b <= l) return d1;\n    if (a <= l && r <= b) return dat[k];\n    Monoid vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    Monoid vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n\n  Monoid query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n\n};"

  # BinaryIndexedTree
  'BinaryIndexedTree':
    'prefix': 'Data Structure'
    'body': "/*\n・BIT (BinaryIndexedTree)\n  > O(logN)\n[備考] ある要素に値を加える操作と, 区間和を求める操作に関してlogNで行うデータ構造\n[使用例]\nBinaryIndexedTree<int> bit(N);      // 要素数NのBIT\nbit.add(k, x);                      // 要素kに値xを加算\nbit.sum(k);                         // 閉区間[0,k]の和を求める\n*/\n\ntemplate<typename T> struct BinaryIndexedTree {\n  vector<T> data;\n  BinaryIndexedTree(int sz) { data.assign(++sz, 0); }\n  T sum(int k) {\n    T ret = 0;\n    for (++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n  void add(int k, T x) { for (++k; k < data.size(); k += k & -k) data[k] += x; }\n};"
  'BinaryIndexedTree ':
    'prefix': 'BinaryIndexedTree'
    'body': "/*\n・BIT (BinaryIndexedTree)\n  > O(logN)\n[備考] ある要素に値を加える操作と, 区間和を求める操作に関してlogNで行うデータ構造\n[使用例]\nBinaryIndexedTree<int> bit(N);      // 要素数NのBIT\nbit.add(k, x);                      // 要素kに値xを加算\nbit.sum(k);                         // 閉区間[0,k]の和を求める\n*/\n\ntemplate<typename T> struct BinaryIndexedTree {\n  vector<T> data;\n  BinaryIndexedTree(int sz) { data.assign(++sz, 0); }\n  T sum(int k) {\n    T ret = 0;\n    for (++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n  void add(int k, T x) { for (++k; k < data.size(); k += k & -k) data[k] += x; }\n};"

  # InversionNumber
  'InversionNumber':
    'prefix': 'InversionNumber'
    'body': "/*\n・転倒数 (Inversion Number)\n  > O(NlogN)\n[備考] i < j かつ a_i > a_j となる組(i,j)の個数. バブルソートのスワップ回数と等しい.\n[注意] BinaryIndexedTreeを上で定義しておくこと.\n[使用例]\nvector<int> v = {3, 1, 5, 4, 2};\nInversionNumber(v);   // -> 5 : vの転倒数\n*/\n\ntemplate<typename T> ll InversionNumber(vector<T> &v) {\n  ll sz = v.size(), ret = 0;\n  vector<T> rev, v_cp = v; sort(v_cp.begin(), v_cp.end());\n  for (auto e : v) rev.emplace_back(lower_bound(v_cp.begin(), v_cp.end(), e) - v_cp.begin());\n  BinaryIndexedTree<T> bit(sz);\n  for (int i = 0; i < sz; ++i) {\n    ret += i - bit.sum(rev[i]);\n    bit.add(rev[i], 1);\n  }\n  return ret;\n}"
  'InversionNumber ':
    'prefix': 'BubbleSort'
    'body': "/*\n・転倒数 (Inversion Number)\n  > O(NlogN)\n[備考] i < j かつ a_i > a_j となる組(i,j)の個数. バブルソートのスワップ回数と等しい.\n[注意] BinaryIndexedTreeを上で定義しておくこと.\n[使用例]\nvector<int> v = {3, 1, 5, 4, 2};\nInversionNumber(v);   // -> 5 : vの転倒数\n*/\n\ntemplate<typename T> ll InversionNumber(vector<T> &v) {\n  ll sz = v.size(), ret = 0;\n  vector<T> rev, v_cp = v; sort(v_cp.begin(), v_cp.end());\n  for (auto e : v) rev.emplace_back(lower_bound(v_cp.begin(), v_cp.end(), e) - v_cp.begin());\n  BinaryIndexedTree<T> bit(sz);\n  for (int i = 0; i < sz; ++i) {\n    ret += i - bit.sum(rev[i]);\n    bit.add(rev[i], 1);\n  }\n  return ret;\n}"
  'InversionNumber  ':
    'prefix': 'BinaryIndexedTree '
    'body': "/*\n・転倒数 (Inversion Number)\n  > O(NlogN)\n[備考] i < j かつ a_i > a_j となる組(i,j)の個数. バブルソートのスワップ回数と等しい.\n[注意] BinaryIndexedTreeを上で定義しておくこと.\n[使用例]\nvector<int> v = {3, 1, 5, 4, 2};\nInversionNumber(v);   // -> 5 : vの転倒数\n*/\n\ntemplate<typename T> ll InversionNumber(vector<T> &v) {\n  ll sz = v.size(), ret = 0;\n  vector<T> rev, v_cp = v; sort(v_cp.begin(), v_cp.end());\n  for (auto e : v) rev.emplace_back(lower_bound(v_cp.begin(), v_cp.end(), e) - v_cp.begin());\n  BinaryIndexedTree<T> bit(sz);\n  for (int i = 0; i < sz; ++i) {\n    ret += i - bit.sum(rev[i]);\n    bit.add(rev[i], 1);\n  }\n  return ret;\n}"

  # SparseTable
  'SparseTable':
    'prefix': 'Data Structure'
    'body': "/*\n・SparseTable\n  > 前処理 O(NlogN)\n  > query O(1)\n[備考] 静的な配列における, 任意区間の最小値を定数時間で求められるデータ構造.\n[使用例]\nSparseTable<int> st(V);     // V(vector)で初期化し, 前処理を行う\nst.query(l,r);              // 半開区間[l,r)における最小値\n*/\n\ntemplate<typename T> struct SparseTable {\n  vector<vector<T>> st;\n  SparseTable() {}\n  SparseTable(const vector<T> &v) {\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.assign(b, vector<T>(1 << b));\n    for(int i = 0; i < v.size(); i++) st[0][i] = v[i];\n    for(int i = 1; i < b; i++) {\n      for(int j = 0; j + (1 << i) <= (1 << b); j++) {\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n  inline T query(int l, int r) {\n    int b = 32 - __builtin_clz(r - l) - 1;\n    return (min(st[b][l], st[b][r - (1 << b)]));\n  }\n};"
  'SparseTable ':
    'prefix': 'SparseTable'
    'body': "/*\n・SparseTable\n  > 前処理 O(NlogN)\n  > query O(1)\n[備考] 静的な配列における, 任意区間の最小値を定数時間で求められるデータ構造.\n[使用例]\nSparseTable<int> st(V);     // V(vector)で初期化し, 前処理を行う\nst.query(l,r);              // 半開区間[l,r)における最小値\n*/\n\ntemplate<typename T> struct SparseTable {\n  vector<vector<T>> st;\n  SparseTable() {}\n  SparseTable(const vector<T> &v) {\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.assign(b, vector<T>(1 << b));\n    for(int i = 0; i < v.size(); i++) st[0][i] = v[i];\n    for(int i = 1; i < b; i++) {\n      for(int j = 0; j + (1 << i) <= (1 << b); j++) {\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n  inline T query(int l, int r) {\n    int b = 32 - __builtin_clz(r - l) - 1;\n    return (min(st[b][l], st[b][r - (1 << b)]));\n  }\n};"
  'SparseTable  ':
    'prefix': 'Minimum'
    'body': "/*\n・SparseTable\n  > 前処理 O(NlogN)\n  > query O(1)\n[備考] 静的な配列における, 任意区間の最小値を定数時間で求められるデータ構造.\n[使用例]\nSparseTable<int> st(V);     // V(vector)で初期化し, 前処理を行う\nst.query(l,r);              // 半開区間[l,r)における最小値\n*/\n\ntemplate<typename T> struct SparseTable {\n  vector<vector<T>> st;\n  SparseTable() {}\n  SparseTable(const vector<T> &v) {\n    int b = 0;\n    while((1 << b) <= v.size()) ++b;\n    st.assign(b, vector<T>(1 << b));\n    for(int i = 0; i < v.size(); i++) st[0][i] = v[i];\n    for(int i = 1; i < b; i++) {\n      for(int j = 0; j + (1 << i) <= (1 << b); j++) {\n        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n      }\n    }\n  }\n  inline T query(int l, int r) {\n    int b = 32 - __builtin_clz(r - l) - 1;\n    return (min(st[b][l], st[b][r - (1 << b)]));\n  }\n};"

  # Other
  'map FOR':
    'prefix': 'for'
    'body': "for (auto itr=$1.begin(); itr!=$1.end(); ++itr) {\n\t$2\n}"
  'map FOR ':
    'prefix': 'map'
    'body': "for (auto itr=$1.begin(); itr!=$1.end(); ++itr) {\n\t$2\n}"

  'めぐる式二分探索':
    'prefix': 'Meguru'
    'body': "ll ok = $1, ng = $2;\nwhile (abs(ok - ng) > 1) {\n  ll mid = (ok + ng) / 2;\n  if (check(mid)) {\n    ok = mid;\n  } else {\n    ng = mid;\n  }\n}"

  'Groupby':
    'prefix': 'groupby'
    'body': "/*\n・groupby\n[備考] stringについて用いる場合は, vector<char>に以下のようにして一旦移し替える.\n      string str;\n      vector<char> vec(str.begin(), str.end());\n[使用例]\nvector<int> vec = {1, 2, 2, 3, 3, 3, 3};\nauto gb = groupby(vec);                       // {{1, 1}, {2, 2}, {3, 4}}\n*/\n\ntemplate<typename T> vector< pair< T, int > > groupby(const vector< T > &vec) {\n  vector< pair< T,int > > ret;\n  int piv = -1;\n  for (auto& e: vec) {\n    if (piv == -1 || ret[piv].first != e) ++piv, ret.emplace_back(make_pair(e, 1));\n    else ++(ret[piv].second);\n  }\n  return ret;\n}"

  # Disable
  '0':
    'prefix': 'cerr'
    'disabled': true
  '1':
    'prefix': 'cin'
    'disabled': true
  '2':
    'prefix': 'cout'
    'disabled': true
  '3':
    'prefix': 'cs'
    'disabled': true
  '4':
    'prefix': 'cl'
    'disabled': true
  '5':
    'prefix': 'def'
    'disabled': true
  '6':
    'prefix': 'do'
    'disabled': true
  '7':
    'prefix': 'enum'
    'disabled': true
  '8':
    'prefix': 'fprintf'
    'disabled': true
  '9':
    'prefix': 'func'
    'disabled': true
  '10':
    'prefix': 'if'
    'disabled': true
  '11':
    'prefix': 'iff'
    'disabled': true
  '12':
    'prefix': 'iffe'
    'disabled': true
  '13':
    'prefix': 'inf'
    'disabled': true
  '14':
    'prefix': 'ife'
    'disabled': true
  '15':
    'prefix': 'inc'
    'disabled': true
  '16':
    'prefix': 'Inc'
    'disabled': true
  '17':
    'prefix': 'main'
    'disabled': true
  '18':
    'prefix': 'mark'
    'disabled': true
  '19':
    'prefix': 'ns'
    'disabled': true
  '20':
    'prefix': 'once'
    'disabled': true
  '21':
    'prefix': 'outf'
    'disabled': true
  '22':
    'prefix': 'printf'
    'disabled': true
  '23':
    'prefix': 'rf'
    'disabled': true
  '24':
    'prefix': 'scanf'
    'disabled': true
  '25':
    'prefix': 'sp'
    'disabled': true
  '26':
    'prefix': 'st'
    'disabled': true
  '27':
    'prefix': 'str'
    'disabled': true
  '28':
    'prefix': 'switch'
    'disabled': true
  '29':
    'prefix': 'td'
    'disabled': true
  '30':
    'prefix': 'tp'
    'disabled': true
  '31':
    'prefix': 'vector'
    'disabled': true
  '32':
    'prefix': 'void'
    'disabled': true
  '33':
    'prefix': 'wf'
    'disabled': true
  '34':
    'prefix': 'while'
    'disabled': true
