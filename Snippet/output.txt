/*\n・セグメント木\n  >         build O(N)\n  > query, update O(logN)\n[備考] 結合律, 単位元を持つ二項演算を, 任意の区間に関してlogNで行うデータ構造\n[使用例]\nSegmentTree<int> seg_sum(N, [](int a, int b){ return a+b; }, 0 );       // 区間和\nSegmentTree<int> seg_min(N, [](int a, int b){ return min(a,b); }, INF); // 区間min\nseg_min.set(k,x);     // 要素kに値xを設定\nseg_min.build();      // 上のセグメントに値を設定\nseg_min.update(k,x);  // 要素kを値xに変更\nseg_min.query(l,r);   // 区間[l,r)に対する二項演算の結果を返す\n*/\n\ntemplate<typename T> struct SegmentTree {\n\n  using F = function< T(T,T) >;\n\n  vector< T > seg;\n\n  int size;       // データの数以上の最小の2冪, 最下段のデータの個数\n  const F func;\n  const T M1;\n\n  SegmentTree(int n, const F f, const T &M) : func(f), M1(M) {\n    size = 1; while (size < n) size *= 2;\n    seg.resize(2 * size - 1, M1);\n  }\n\n  void set(int k, int x) {\n    seg[k + size - 1] = x;\n  }\n\n  void build() {\n    for (int i = size - 2; i >= 0; --i) {\n      // iの子は, (2*i+1, 2*i+2)\n      seg[i] = func(seg[2*i+1], seg[2*i+2]);\n    }\n  }\n\n  void update(int k, int x) {\n    // kをseg内の添字に対応させる <- (size - 1)を足す\n    k += size - 1;\n    seg[k] += x;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      seg[k] = func(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = size;\n    if (r <= a || l >= b) return M1;\n    if (l >= a && r <= b) return seg[k];\n    T f_l = query(a, b, 2*k+1, l, (l+r)/2);\n    T f_r = query(a, b, 2*k+2, (l+r)/2, r);\n    return func(f_l, f_r);\n  }\n\n  void debug() {\n    for (int i = 0; i < 2 * size - 1; ++i) {\n      cout << seg[i] << \" \n\"[i==2*size-2];\n    }\n  }\n\n};
