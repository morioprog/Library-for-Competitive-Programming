#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\ntypedef long long ll;       typedef long double ld;  typedef pair<int,int> pii; typedef pair<ll,ll> pll;  typedef vector<int> vi;   typedef vector<ll> vl;\ntypedef vector<string> vst; typedef vector<bool> vb; typedef vector<ld> vld;    typedef vector<pii> vpii; typedef vector<pll> vpll; typedef vector<vector<int> > vvi;\nconst int INF = (0x7FFFFFFFL); const ll INFF = (0x7FFFFFFFFFFFFFFFL); const string ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";\nconst int MOD = 1e9 + 7;       const int MODD = 998244353;            const string alphabet = "abcdefghijklmnopqrstuvwxyz";\nconst double PI = acos(-1.0);  const double EPS = 1e-9;               const string Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\nint dx[9] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };\nint dy[9] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };\n#define ln '\n'\n#define scnaf scanf\n#define sacnf scanf\n#define sancf scanf\n#define SS(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t){cin >> t;}template<typename First, typename...Rest> void MACRO_VAR_Scan(First& first, Rest&...rest){cin >> first;MACRO_VAR_Scan(rest...);}\n#define SV(type,c,n) vector<type> c(n);for(auto& i:c)cin >> i;\n#define SVV(type,c,n,m) vector<vector<type>> c(n,vector<type>(m));for(auto& r:c)for(auto& i:r)cin >> i;\ntemplate<class T>ostream &operator<<(ostream &o,const vector<T>&j){o<<"{";for(int i=0;i<(int)j.size();++i)o<<(i>0?", ":"")<<j[i];o<<"}";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const pair<T,U>&j){o<<"{"<<j.first<<", "<<j.second<<"}";return o;}\ntemplate<class T,class U>ostream &operator<<(ostream &o,const map<T,U>&j){o<<"{";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?", ":"")<<*t;o<<"}";return o;}\ntemplate<class T>ostream &operator<<(ostream &o,const set<T>&j){o<<"{";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?", ":"")<<*t;o<<"}";return o;}\ninline void print(void){cout << endl;}\ntemplate<class Head> void print(Head&& head){cout << head;print();} template<class Head,class... Tail> void print(Head&& head,Tail&&... tail){cout<<head<<" ";print(forward<Tail>(tail)...);}\ninline void debug(void){cerr << endl;}\ntemplate<class Head> void debug(Head&& head){cerr << head;debug();} template<class Head,class... Tail> void debug(Head&& head,Tail&&... tail){cerr<<head<<" ";debug(forward<Tail>(tail)...);}\ntemplate<typename T> void PA(T &a){int ASIZE=sizeof(a)/sizeof(a[0]);for(int ii=0;ii<ASIZE;++ii){cout<<a[ii]<<" \n"[ii==ASIZE-1];}}\ntemplate<typename T> void PV(T &v){int VSIZE=v.size();for(int ii=0;ii<VSIZE;++ii){cout<<v[ii]<<" \n"[ii==VSIZE-1];}}\n#define ER(x)  cerr << #x << " = " << (x) << endl;\n#define ERV(v) {cerr << #v << " : ";for(const auto& xxx : v){cerr << xxx << " ";}cerr << "\n";}\ninline void YES(bool x){cout<<((x)?"YES":"NO")<<endl;} inline void Yes(bool x){cout<<((x)?"Yes":"No")<<endl;}  inline void yes(bool x){cout<<((x)?"yes":"no")<<endl;}\ninline void yES(bool x){cout<<((x)?"yES":"nO")<<endl;} inline void Yay(bool x){cout<<((x)?"Yay!":":(")<<endl;}\ntemplate<typename A,typename B> void sankou(bool x,A a,B b){cout<<((x)?(a):(b))<<endl;}\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REPI(i,0,n)\n#define REPI(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REPI,_REP,)(__VA_ARGS__)\n#define _RREP(i,n) RREPI(i,n,0)\n#define RREPI(i,a,b) for(ll i=ll(a);i>=ll(b);--i)\n#define RREP(...) _overload3(__VA_ARGS__,RREPI,_RREP,)(__VA_ARGS__)\n#define EACH(e,v) for(auto& e : v)\n#define PERM(v) sort((v).begin(),(v).end());for(bool c##p=1;c##p;c##p=next_permutation((v).begin(),(v).end()))\n#define ADD(a,b) a=(a+ll(b))%MOD\n#define MUL(a,b) a=(a*ll(b))%MOD\ninline ll MOP(ll x,ll n,ll m=MOD){ll r=1;while(n>0){if(n&1)(r*=x)%=m;(x*=x)%=m;n>>=1;}return r;}\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}inline ll POW(ll a,ll b){ll c=1ll;do{if(b&1)c*=1ll*a;a*=1ll*a;}while(b>>=1);return c;}\ntemplate<typename T> inline bool between(T x,T a,T b) {return ((a<=x)&&(x<b));}template<class T> inline T sqr(T x){return x*x;}\ntemplate<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}\n#define tmax(x,y,z) max((x),max((y),(z)))\n#define tmin(x,y,z) min((x),min((y),(z)))\n#define PB push_back\n#define MP make_pair\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define SORT(v) sort((v).begin(),(v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define EXIST(s,e) (find((s).begin(),(s).end(),(e))!=(s).end())\n#define EXISTST(s,c) (((s).find(c))!=string::npos)\n#define POSL(x,val) (lower_bound(x.begin(),x.end(),val)-x.begin())\n#define POSU(x,val) (upper_bound(x.begin(),x.end(),val)-x.begin())\n#define SZV(a) int((a).size())\n#define SZA(a) sizeof(a)/sizeof(a[0])\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MEMINF(a) memset(a,0x3f,sizeof(a))\n#define FILL(a,b) memset(a,b,sizeof(a))\n#define UNIQUE(v) sort((v).begin(),(v).end());(v).erase(unique((v).begin(),(v).end()),(v).end())\nstruct abracadabra{\n    abracadabra(){\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << fixed << setprecision(20);\n    };\n} ABRACADABRA;\n\n//---------------8<---------------8<---------------8<---------------8<---------------//\n\nsigned main() {\n\n  $1\n\n}
