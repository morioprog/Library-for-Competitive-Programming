{
	"Template": {
		"prefix": [
			"template",
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"//#define int long long",
			"//TEMPLATE START---------------8<---------------8<---------------8<---------------8<---------------//",
			"typedef long long ll;       typedef long double ld;  typedef pair<int,int> pii; typedef pair<ll,ll> pll;  typedef vector<int> vi;   typedef vector<ll> vl;",
			"typedef vector<string> vst; typedef vector<bool> vb; typedef vector<ld> vld;    typedef vector<pii> vpii; typedef vector<pll> vpll; typedef vector<vector<int> > vvi;",
			"const int INF = (0x7FFFFFFFL); const ll INFF = (0x7FFFFFFFFFFFFFFFL); const string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";",
			"const int MOD = 1e9 + 7;       const int MODD = 998244353;            const string alphabet = \"abcdefghijklmnopqrstuvwxyz\";",
			"const double PI = acos(-1.0);  const double EPS = 1e-9;               const string Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";",
			"int dx[9] = { 1, 0, -1,  0,  1, -1, -1, 1, 0 };",
			"int dy[9] = { 0, 1,  0, -1, -1, -1,  1, 1, 0 };",
			"#define ln '\\\\n'",
			"#define scnaf scanf",
			"#define sacnf scanf",
			"#define sancf scanf",
			"#define SS(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);",
			"template<typename T> void MACRO_VAR_Scan(T& t){cin >> t;}template<typename First, typename...Rest> void MACRO_VAR_Scan(First& first, Rest&...rest){cin >> first;MACRO_VAR_Scan(rest...);}",
			"#define SV(type,c,n) vector<type> c(n);for(auto& i:c)cin >> i;",
			"#define SVV(type,c,n,m) vector<vector<type>> c(n,vector<type>(m));for(auto& r:c)for(auto& i:r)cin >> i;",
			"template<class T,class U>ostream &operator<<(ostream &o,const pair<T,U>&j){o<<\"{\"<<j.first<<\", \"<<j.second<<\"}\";return o;}",
			"template<class T,class U>ostream &operator<<(ostream &o,const map<T,U>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}",
			"template<class T>ostream &operator<<(ostream &o,const set<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}",
			"template<class T>ostream &operator<<(ostream &o,const multiset<T>&j){o<<\"{\";for(auto t=j.begin();t!=j.end();++t)o<<(t!=j.begin()?\", \":\"\")<<*t;o<<\"}\";return o;}",
			"template<class T>ostream &operator<<(ostream &o,const vector<T>&j){o<<\"{\";for(int i=0;i<(int)j.size();++i)o<<(i>0?\", \":\"\")<<j[i];o<<\"}\";return o;}",
			"inline int print(void){cout << endl; return 0;}",
			"template<class Head> int print(Head&& head){cout << head;print();return 0;} template<class Head,class... Tail> int print(Head&& head,Tail&&... tail){cout<<head<<\" \";print(forward<Tail>(tail)...);return 0;}",
			"#ifdef LOCAL",
			"inline int dump(void){cerr << endl; return 0;}",
			"template<class Head> int dump(Head&& head){cerr << head;dump();return 0;}",
			"template<class Head,class... Tail> int dump(Head&& head,Tail&&... tail){cerr<<head<<\" \";dump(forward<Tail>(tail)...);return 0;}",
			"#define debug(...) do{cerr<<__LINE__<<\":\t\"<<#__VA_ARGS__<<\" = \";dump(__VA_ARGS__);}while(0)",
			"#define ER(x)  cerr << #x << \" = \" << (x) << endl;",
			"#define ERV(v) {cerr << #v << \" : \";for(const auto& xxx : v){cerr << xxx << \" \";}cerr << \"\\\\n\";}",
			"#else",
			"#define dump(...)",
			"#define debug(...)",
			"#define ER(x)",
			"#define ERV(v)",
			"#endif",
			"template<typename T> void PA(T &a){int ASIZE=sizeof(a)/sizeof(a[0]);for(int ii=0;ii<ASIZE;++ii){cout<<a[ii]<<\" \\\\n\"[ii==ASIZE-1];}}",
			"template<typename T> void PV(T &v){int VSIZE=v.size();for(int ii=0;ii<VSIZE;++ii){cout<<v[ii]<<\" \\\\n\"[ii==VSIZE-1];}}",
			"inline int YES(bool x){cout<<((x)?\"YES\":\"NO\")<<endl;return 0;} inline int Yes(bool x){cout<<((x)?\"Yes\":\"No\")<<endl;return 0;}  inline int yes(bool x){cout<<((x)?\"yes\":\"no\")<<endl;return 0;}",
			"inline int yES(bool x){cout<<((x)?\"yES\":\"nO\")<<endl;return 0;} inline int Yay(bool x){cout<<((x)?\"Yay!\":\":(\")<<endl;return 0;}",
			"template<typename A,typename B> void sankou(bool x,A a,B b){cout<<((x)?(a):(b))<<endl;}",
			"#define _overload3(_1,_2,_3,name,...) name",
			"#define _REP(i,n) REPI(i,0,n)",
			"#define REPI(i,a,b) for(ll i=ll(a);i<ll(b);++i)",
			"#define REP(...) _overload3(__VA_ARGS__,REPI,_REP,)(__VA_ARGS__)",
			"#define _RREP(i,n) RREPI(i,n,0)",
			"#define RREPI(i,a,b) for(ll i=ll(a);i>=ll(b);--i)",
			"#define RREP(...) _overload3(__VA_ARGS__,RREPI,_RREP,)(__VA_ARGS__)",
			"#define EACH(e,v) for(auto& e : v)",
			"#define PERM(v) sort((v).begin(),(v).end());for(bool c##p=1;c##p;c##p=next_permutation((v).begin(),(v).end()))",
			"#define ADD(a,b) a=(a+ll(b))%MOD",
			"#define MUL(a,b) a=(a*ll(b))%MOD",
			"inline ll MOP(ll x,ll n,ll m=MOD){ll r=1;while(n>0){if(n&1)(r*=x)%=m;(x*=x)%=m;n>>=1;}return r;}",
			"inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}inline ll lcm(ll a,ll b){return a*b/gcd(a,b);}inline ll POW(ll a,ll b){ll c=1ll;do{if(b&1)c*=1ll*a;a*=1ll*a;}while(b>>=1);return c;}",
			"template<typename T,typename A,typename B> inline bool between(T x,A a,B b) {return ((a<=x)&&(x<b));}template<class T> inline T sqr(T x){return x*x;}",
			"template<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}",
			"template<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}",
			"#define tmax(x,y,z) max((x),max((y),(z)))",
			"#define tmin(x,y,z) min((x),min((y),(z)))",
			"#define PB emplace_back",
			"#define MP make_pair",
			"#define MT make_tuple",
			"#define all(v) (v).begin(),(v).end()",
			"#define rall(v) (v).rbegin(),(v).rend()",
			"#define SORT(v) sort((v).begin(),(v).end())",
			"#define RSORT(v) sort((v).rbegin(),(v).rend())",
			"#define EXIST(s,e) (find((s).begin(),(s).end(),(e))!=(s).end())",
			"#define EXISTST(s,c) (((s).find(c))!=string::npos)",
			"#define POSL(x,val) (lower_bound(x.begin(),x.end(),val)-x.begin())",
			"#define POSU(x,val) (upper_bound(x.begin(),x.end(),val)-x.begin())",
			"#define GEQ(x,val) (int)(x).size() - POSL((x),(val))",
			"#define GREATER(x,val) (int)(x).size() - POSU((x),(val))",
			"#define LEQ(x,val) POSU((x),(val))",
			"#define LESS(x,val) POSL((x),(val))",
			"#define SZV(a) int((a).size())",
			"#define SZA(a) sizeof(a)/sizeof(a[0])",
			"#define ZERO(a) memset(a,0,sizeof(a))",
			"#define MINUS(a) memset(a,0xff,sizeof(a))",
			"#define MEMINF(a) memset(a,0x3f,sizeof(a))",
			"#define FILL(a,b) memset(a,b,sizeof(a))",
			"#define UNIQUE(v) sort((v).begin(),(v).end());(v).erase(unique((v).begin(),(v).end()),(v).end())",
			"struct abracadabra{",
			"	abracadabra(){",
			"		cin.tie(0); ios::sync_with_stdio(0);",
			"		cout << fixed << setprecision(20);",
			"		cerr << fixed << setprecision(5);",
			"	};",
			"} ABRACADABRA;",
			"",
			"//TEMPLATE END---------------8<---------------8<---------------8<---------------8<---------------//",
			"",
			"signed main() {",
			"",
			"	$0",
			"",
			"}",
		],
	},
	"Template(short)": {
		"prefix": [
			"template",
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"typedef long long ll;",
			"#define REP(i,n) for(int (i)=0;(i)<(n);++(i))",
			"#define FOR(i,a,b) for(int (i)=(a);(i)<(b);++(i))",
			"#define EACH(e,v) for(auto& e:v)",
			"#define ALL(v) (v).begin(),(v).end()",
			"#define SORT(v) sort(ALL(v))",
			"#define RSORT(v) sort((v).rbegin(),(v).rend())",
			"#define PERM(v) SORT(v);for(bool c##p=1;c##p;c##p=next_permutation(ALL(v)))",
			"#define UNIQUE(v) SORT(v);(v).erase(unique(ALL(v)),(v).end())",
			"template<typename A,typename B> inline bool chmax(A &a,const B &b){if(a<b){a=b;return 1;}return 0;}",
			"template<typename A,typename B> inline bool chmin(A &a,const B &b){if(a>b){a=b;return 1;}return 0;}",
			"",
			"const int MOD = (int)1e9 + 7;",
			"const int INF = 1 << 30;",
			"const ll INFF = 1LL << 62;",
			"",
			"// 下にy, 右にx",
			"enum {R, U, L, D};",
			"const int dx[] = {1,  0, -1, 0};",
			"const int dy[] = {0, -1,  0, 1};",
			"",
			"signed main() {",
			"",
			"    $0",
			"",
			"}",
		],
	},
	"Template(shortshort)": {
		"prefix": [
			"template",
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using i64 = int_fast64_t;",
			"using ui64 = uint_fast64_t;",
			"#define REP(i, n) for (i64 (i) = 0; (i) < (n); ++(i))",
			"#define FOR(i, a, b) for (i64 (i) = (a); (i) < (b); ++(i))",
			"",
			"signed main() {",
			"",
			"    $0",
			"",
			"}",
		],
	},
	"めぐる式二分探索": {
		"prefix": [
			"meguru",
		],
		"body": [
			"int_fast64_t ok = $1, ng = $2;",
			"while (abs(ok - ng) > 1) {",
			"    int_fast64_t mid = (ok + ng) >> 1;",
			"    if (check(mid)) {",
			"        ok = mid;",
			"    } else {",
			"        ng = mid;",
			"    }",
			"}",
		],
	},
	"平方分割": {
		"prefix": [
			"heihoubunkatu",
			"square root decomposition",
		],
		"body": [
			"const int bucketSize = 400",
			"function<int(int, int)> query = [&](int l, int r) {",
			"    int ret = 0;",
			"    for (int x = l; x < r;) {",
			"        int bi = x / bucketSize;",
			"        if (l <= bi * bucketSize and (bi + 1) * bucketSize <= r) {",
			"            // バケット",
			"            x += bucketSize;",
			"        } else {",
			"            // 余った部分",
			"            ++x;",
			"        }",
			"    }",
			"    return ret;",
			"};",
		],
	},
	"高速フーリエ変換による畳み込み": {
		"prefix": [
			"convolution",
			"fastfouriertransform",
		],
		"body": [
			"namespace FastFourierTransform {",
			"    using C = complex< double >;",
			"    void DiscreteFourierTransform(vector< C > &F, bool rev) {",
			"        const int N = (int)F.size();",
			"        const double PI = (rev ? -1 : 1) * acos(-1);",
			"        for (int i = 0, j = 1; j + 1 < N; ++j) {",
			"            for (int k = N >> 1; k > (i ^= k); k >>= 1);",
			"            if (i > j) swap(F[i], F[j]);",
			"        }",
			"        C w, s, t;",
			"        for (int i = 1; i < N; i <<= 1) {",
			"            for (int k = 0; k < i; ++k) {",
			"                w = polar(1.0, PI / i * k);",
			"                for (int j = 0; j < N; j += i * 2) {",
			"                    s = F[j + k];",
			"                    t = C(",
			"                        F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),",
			"                        F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real()",
			"                    );",
			"                    F[j + k] = s + t, F[j + k + i] = s - t;",
			"                }",
			"            }",
			"        }",
			"        if (rev) for (int i = 0; i < N; ++i) F[i] /= N;",
			"    }",
			"    vector<int_fast64_t> Multiply(const vector<int> &A, const vector<int> &B) {",
			"        int sz = 1;",
			"        while (sz < A.size() + B.size() - 1) sz <<= 1;",
			"        vector< C > F(sz), G(sz);",
			"        for (int i = 0; i < A.size(); ++i) F[i] = A[i];",
			"        for (int i = 0; i < B.size(); ++i) G[i] = B[i];",
			"        DiscreteFourierTransform(F, false);",
			"        DiscreteFourierTransform(G, false);",
			"        for (int i = 0; i < sz; ++i) F[i] *= G[i];",
			"        DiscreteFourierTransform(F, true);",
			"        vector<int_fast64_t> X(A.size() + B.size() - 1);",
			"        for (int i = 0; i < A.size() + B.size() - 1; ++i) X[i] = F[i].real() + 0.5;",
			"        return X;",
			"    }",
			"};",
			"",
			"/*",
			"・高速フーリエ変換",
			"    > O(NlogN)",
			"[備考] 畳み込み(c_i = Sum[j = 0..i] a_j * b_(i - j))を高速に行える.",
			"[使用例] vector<int_fast64_t> C = FastFourierTransform::Multiply(A, B);      // AとBの畳み込みの結果をCに代入",
			"[参考] https://www.creativ.xyz/fast-fourier-transform/",
			"*/",
		],
	},
	"1次元累積和": {
		"prefix": [
			"cumulativesum",
			"imos",
			"accumulate",
		],
		"body": [
			"template<typename T = int_fast64_t> struct CumulativeSum {",
			"    vector< T > data;",
			"    CumulativeSum(int sz, T init = 0) : data(sz, init) {}",
			"    void add(int k, T x) {",
			"        data[k] += x;",
			"        // data[k] ^= x;",
			"    }",
			"    void build() {",
			"        for (int i = 1; i < (int)data.size(); ++i) {",
			"            data[i] += data[i - 1];",
			"            // data[i] ^= data[i - 1];",
			"        }",
			"    }",
			"    T query(int k) {",
			"        if (k < 0) return 0;",
			"        return data[min(k, (int)data.size() - 1)];",
			"    }",
			"    T query(int l, int r) {",
			"        T ret = (data[min(r - 1, (int)data.size() - 1)]);",
			"        if (l > 0) ret -= (data[min(l - 1, (int)data.size() - 1)]);",
			"        // if (l > 0) ret ^= (data[min(l - 1, (int)data.size() - 1)]);",
			"        return ret;",
			"    }",
			"    T operator[](const int &k) {",
			"        return data[k];",
			"    }",
			"    void debug() {",
			"        for (int i = 0; i < (int)data.size(); ++i) cerr << data[i] << ' ';",
			"        cerr << endl;",
			"    }",
			"};",
			"",
			"/*",
			"・1次元累積和",
			"    >     build O(N)",
			"    > add,query O(1)",
			"[応用例] 加減算をそれぞれXORにすると, 累積XOR",
			"[使用例]",
			"CumulativeSum<int> acc(N);  // 要素数Nの累積和用の配列",
			"acc.add(k, x);              // 要素kに値xを加える",
			"acc.build();                // 累積和を取る",
			"acc.query(k);               // 閉区間[0, k]の和",
			"acc.query(l, r);            // 半開区間[l, r)の和",
			"acc[k];                     // 要素kを取得",
			"*/",
		],
	},
	"2次元累積和": {
		"prefix": [
			"cumulativesum2D",
			"imos",
			"accumulate",
		],
		"body": [
			"template<typename T = int_fast64_t> struct CumulativeSum2D {",
			"    vector< vector< T > > data;",
			"    CumulativeSum2D(int W, int H) : data(W + 1, vector<T>(H + 1, 0)) {}",
			"    void add(int x, int y, int z) {",
			"        ++x, ++y;",
			"        if (x >= data.size() || y >= data[0].size()) return;",
			"        data[x][y] += z;",
			"    }",
			"    void build() {",
			"        for(int i = 1; i < data.size(); ++i) {",
			"            for(int j = 1; j < data[i].size(); ++j) {",
			"                data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
			"            }",
			"        }",
			"    }",
			"    T query(int sx, int sy, int gx, int gy) {",
			"        return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);",
			"    }",
			"};",
			"",
			"/*",
			"・2次元累積和",
			"    >     build O(W * H)",
			"    > add,query O(1)",
			"[使用例]",
			"CumulativeSum2D<int> acc(W, H);     // acc[W + 1][H + 1]",
			"acc.add(L, R, x);                   // 要素(L, R)に値xを加える",
			"acc.build();                        // 累積和を取る",
			"acc.query(a, b, c, d);              // [a, b]から(c, d)までの和",
			"*/",
		],
	},
	"セグメント木": {
		"prefix": [
			"data structure",
			"segment tree",
		],
		"body": [
			"template<typename T> struct SegmentTree {",
			"    using F = function< T(T, T) >;",
			"    vector< T > seg;",
			"    int size;       // データの数以上の最小の2冪, 最下段のデータの個数",
			"    const F func;",
			"    const T M1;",
			"    SegmentTree(int n, const F f, const T &M) : func(f), M1(M) {",
			"        size = 1; while (size < n) size <<= 1;",
			"        seg.resize(2 * size - 1, M1);",
			"    }",
			"    void set(int k, T x) {",
			"        seg[k + size - 1] = x;",
			"    }",
			"    void build() {",
			"        for (int i = size - 2; i >= 0; --i) {",
			"            // iの子は, (2 * i + 1, 2 * i + 2)",
			"            seg[i] = func(seg[2 * i + 1], seg[2 * i + 2]);",
			"        }",
			"    }",
			"    void update(int k, T x) {",
			"        // kをseg内の添字に対応させる <- (size - 1)を足す",
			"        k += size - 1;",
			"        seg[k] = x;",
			"        while (k > 0) {",
			"            k = (k - 1) / 2;",
			"            seg[k] = func(seg[2 * k + 1], seg[2 * k + 2]);",
			"        }",
			"    }",
			"    void add(int k, T x) {",
			"        // kをseg内の添字に対応させる <- (size - 1)を足す",
			"        k += size - 1;",
			"        seg[k] += x;",
			"        while (k > 0) {",
			"            k = (k - 1) / 2;",
			"            seg[k] = func(seg[2 * k + 1], seg[2 * k + 2]);",
			"        }",
			"    }",
			"    T query(int a, int b, int k = 0, int l = 0, int r = -1) {",
			"        if (r < 0) r = size;",
			"        if (r <= a || l >= b) return M1;",
			"        if (l >= a && r <= b) return seg[k];",
			"        T f_l = query(a, b, 2 * k + 1, l, (l + r) / 2);",
			"        T f_r = query(a, b, 2 * k + 2, (l + r) / 2, r);",
			"        return func(f_l, f_r);",
			"    }",
			"    void debug() {",
			"        for (int i = 0; i < 2 * size - 1; ++i) {",
			"            cerr << seg[i] << \" \\\\n\"[i == 2 * size - 2];",
			"        }",
			"    }",
			"};",
			"",
			"/*",
			"・セグメント木",
			"    >         build O(N)",
			"    > query, update O(logN)",
			"[備考] 結合律, 単位元を持つ二項演算を, 任意の区間に関してlogNで行うデータ構造",
			"[使用例]",
			"SegmentTree<int> seg(N, [](int a, int b){ return a + b; }, 0 );     // 区間和",
			"SegmentTree<int> seg(N, [](int a, int b){ return min(a,b); }, INF); // 区間min",
			"seg.set(k, x);      // 要素kに値xを設定",
			"seg.build();        // 上のセグメントに値を設定",
			"seg.update(k, x);   // 要素kを値xに変更",
			"seg.add(k, x);      // 要素kに値xを加算",
			"seg.query(l, r);    // 半開区間[l, r)に対する二項演算の結果を返す",
			"*/",
		],
	},
	"遅延セグメント木": {
		"prefix": [
			"data structure",
			"segment tree",
			"lazy segment tree",
		],
		"body": [
			"template <typename Monoid, typename OperatorMonoid = Monoid> struct LazySegmentTree {",
			"    typedef function< Monoid(Monoid, Monoid) > F;",
			"    typedef function< Monoid(Monoid, OperatorMonoid) > G;",
			"    typedef function< OperatorMonoid(OperatorMonoid, OperatorMonoid) > H;",
			"    typedef function< OperatorMonoid(OperatorMonoid, int) > P;",
			"    int sz;",
			"    F f; G g; H h; P p;",
			"    Monoid d1; OperatorMonoid d0;",
			"    vector< Monoid > dat;",
			"    vector< OperatorMonoid > laz;",
			"    LazySegmentTree(int n, F f, G g, H h, Monoid d1, OperatorMonoid d0,",
			"        vector< Monoid > v = vector< Monoid >(), P p = [] (OperatorMonoid a, int b) { return a; })",
			"        : f(f), g(g), h(h), d1(d1), d0(d0), p(p) {",
			"        sz = 1; while (sz < n) sz <<= 1;",
			"        dat.assign(2 * sz - 1, d1);",
			"        laz.assign(2 * sz - 1, d0);",
			"        if (n == (int)v.size()) build(n, v);",
			"    }",
			"    void build(int n, vector<Monoid> &v) {",
			"        for (int i = 0; i < n; ++i) dat[i + sz - 1] = v[i];",
			"        for (int i = sz - 2; i >= 0; --i) dat[i] = f(dat[2 * i + 1], dat[2 * i + 2]);",
			"    }",
			"    inline void eval(int len, int k) {",
			"        if (laz[k] == d0) return;",
			"        if (2 * k + 1 < 2 * sz - 1) {",
			"            laz[2 * k + 1] = h(laz[2 * k + 1], laz[k]);",
			"            laz[2 * k + 2] = h(laz[2 * k + 2], laz[k]);",
			"        }",
			"        dat[k] = g(dat[k], p(laz[k], len));",
			"        laz[k] = d0;",
			"    }",
			"    Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r) {",
			"        eval(r - l, k);",
			"        if (r <= a or b <= l) return dat[k];",
			"        if (a <= l and r <= b) {",
			"            laz[k] = h(laz[k], x);",
			"            return g(dat[k], p(laz[k], r - l));",
			"        }",
			"        return dat[k] = f(update(a, b, x, 2 * k + 1, l, (l + r) / 2), update(a, b, x, 2 * k + 2, (l + r) / 2, r));",
			"    }",
			"    Monoid update(int a, int b, OperatorMonoid x) {",
			"        return update(a, b, x, 0, 0, sz);",
			"    }",
			"    Monoid query(int a, int b, int k, int l, int r) {",
			"        eval(r - l, k);",
			"        if (r <= a or b <= l) return d1;",
			"        if (a <= l and r <= b) return dat[k];",
			"        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);",
			"        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);",
			"        return f(vl, vr);",
			"    }",
			"    Monoid query(int a, int b) {",
			"        return query(a, b, 0, 0, sz);",
			"    }",
			"    Monoid operator[](const int &k) {",
			"        return query(k, k + 1);",
			"    }",
			"};",
			"",
			"/*",
			"・遅延評価セグメント木",
			"    > query, update O(logN)",
			"[引数]",
			"LazySegmentTree<Monoid, OperatorMonoid> seg(sz, f, g, h, d1, d0, v, p);",
			"> sz : 要素数",
			">  f : 要素と要素をマージする関数",
			">  g : 要素に作用素を作用させる関数",
			">  h : 作用素と作用素をマージする関数",
			"> d1 : 要素のモノイド",
			"> d0 : 作用素のモノイド",
			">  v : 初期化用の配列",
			">  p : 区間に対する操作が要素数に比例して変化する場合 ( p(a, b) = g(a, a, ..., a) [aはb個] )",
			"[備考]",
			"以下の3つの条件を満たすときに使える",
			"1. g(f(a, b), c) = f(g(a, c), g(b, c))",
			"( 1'. g(f(a, b), p(c, d)) = f(g(a, p(c, d / 2)), g(b, p(c, d / 2))) )",
			"2. g(g(a, b), c) = g(a, h(b, c))",
			"3. g(a, d0) = a",
			"[典型例]",
			"> 区間加算 -> 区間和",
			"LazySegmentTree<ll> seg(N, plus<ll>(), plus<ll>(), plus<ll>(), 0, 0, vector<ll>(N, 0), multiplies<ll>());",
			"> 区間加算 -> 区間最小",
			"LazySegmentTree<ll> seg(N, [](ll a, ll b){ return min(a, b); }, plus<ll>(), plus<ll>(), INFF, 0);",
			"> 区間更新 -> 区間和",
			"LazySegmentTree<ll> seg(N, plus<ll>(), [](ll a, ll b){ return b; }, [](ll a, ll b){ return b; }, 0, INFF, vector<ll>(N, 0), multiplies<ll>());",
			"> 区間更新 -> 区間最小",
			"LazySegmentTree<ll> seg(N, [](ll a,ll b){ return min(a,b); }, [](ll a, ll b){ return b; }, [](ll a, ll b){ return b; }, INFF, INFF);",
			"[使用例]",
			"seg.update(l, r, x);        // 半開区間[l, r)に作用素xを作用",
			"seg.query(l, r);            // 半開区間[l, r)に対する演算の結果",
			"seg[k];                     // k番目の要素を取得",
			"*/",
		],
	},
	"Segment Tree Beats": {
		"prefix": [
			"data structure",
			"segment tree",
			"beats",
		],
		"body": [
			"struct SegmentTreeBeats {",
			"    static const int_fast64_t INF = 1LL << 60;",
			"    struct Node {",
			"        Node *left, *right;",
			"        int_fast64_t max_v, smax_v, max_c;",
			"        int_fast64_t min_v, smin_v, min_c;",
			"        int_fast64_t sum;",
			"        int_fast64_t len, ladd, lval;",
			"",
			"        Node() : left(0), right(0), ladd(0), lval(INF) {}",
			"",
			"        void init(int_fast64_t x) {",
			"            max_v = min_v = sum = x;",
			"            smax_v = -INF; smin_v = INF;",
			"            max_c = min_c = 1;",
			"        }",
			"",
			"        void init_empty() {",
			"            max_v = smax_v = -INF;",
			"            min_v = smin_v = INF;",
			"            max_c = min_c = 0;",
			"        }",
			"",
			"        void update_max(int_fast64_t x) {",
			"            sum += (x - max_v) * max_c;",
			"            /* */if (max_v ==  min_v) max_v =  min_v = x;",
			"            else if (max_v == smin_v) max_v = smin_v = x;",
			"            else                      max_v = x;",
			"            if (lval != INF and x < lval) lval = x;",
			"        }",
			"",
			"        void update_min(int_fast64_t x) {",
			"            sum += (x - min_v) * min_c;",
			"            /* */if (max_v ==  min_v) max_v =  min_v = x;",
			"            else if (max_v == smin_v) min_v = smax_v = x;",
			"            else                      min_v = x;",
			"            if (lval != INF and lval < x) lval = x;",
			"        }",
			"",
			"        void addall(int_fast64_t x) {",
			"            max_v += x;",
			"            if (smax_v != -INF) smax_v += x;",
			"            min_v += x;",
			"            if (smin_v != INF) smin_v += x;",
			"            sum += len * x;",
			"            if (lval != INF) lval += x;",
			"            else             ladd += x;",
			"        }",
			"",
			"        void updateall(int_fast64_t x) {",
			"            max_v = min_v = x;",
			"            smax_v = -INF; smin_v = INF;",
			"            max_c = min_c = len;",
			"            sum = len * x;",
			"            lval = x; ladd = 0;",
			"        }",
			"",
			"        void push() {",
			"            if (lval != INF) {",
			"                 left -> updateall(lval);",
			"                right -> updateall(lval);",
			"                lval = INF;",
			"                return;",
			"            }",
			"            if (ladd != 0) {",
			"                 left -> addall(ladd);",
			"                right -> addall(ladd);",
			"                ladd = 0;",
			"            }",
			"            if (max_v < left -> max_v)   left -> update_max(max_v);",
			"            if (left -> min_v < min_v)   left -> update_min(min_v);",
			"            if (max_v < right -> max_v) right -> update_max(max_v);",
			"            if (right -> min_v < min_v) right -> update_min(min_v);",
			"        }",
			"",
			"        void update() {",
			"            sum = left -> sum + right -> sum;",
			"            if (left -> max_v < right -> max_v) {",
			"                max_v = right -> max_v;",
			"                max_c = right -> max_c;",
			"                smax_v = max(left -> max_v, right -> smax_v);",
			"            } else if (left -> max_v > right -> max_v) {",
			"                max_v = left -> max_v;",
			"                max_c = left -> max_c;",
			"                smax_v = max(left -> smax_v, right -> max_v);",
			"            } else {",
			"                max_v = left -> max_v;",
			"                max_c = left -> max_c + right -> max_c;",
			"                smax_v = max(left -> smax_v, right -> smax_v);",
			"            }",
			"            if (left -> min_v < right -> min_v) {",
			"                min_v = left -> min_v;",
			"                min_c = left -> min_c;",
			"                smin_v = min(left -> smin_v, right -> min_v);",
			"            } else if (left -> min_v > right -> min_v) {",
			"                min_v = right -> min_v;",
			"                min_c = right -> min_c;",
			"                smin_v = min(left -> min_v, right -> smin_v);",
			"            } else {",
			"                min_v = left -> min_v;",
			"                min_c = left -> min_c + right -> min_c;",
			"                smin_v = min(left -> smin_v, right -> smin_v);",
			"            }",
			"        }",
			"    };",
			"",
			"    int n, n0;",
			"    Node *root;",
			"",
			"    void _update_min(int_fast64_t x, int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a || nd -> max_v <= x) return;",
			"        if (a <= l && r <= b && nd -> smax_v < x) {",
			"            nd -> update_max(x);",
			"            return;",
			"        }",
			"        nd -> push();",
			"        _update_min(x, a, b, nd ->  left, l, (l + r) >> 1);",
			"        _update_min(x, a, b, nd -> right, (l + r) >> 1, r);",
			"        nd -> update();",
			"    }",
			"",
			"    void _update_max(int_fast64_t x, int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a || x <= nd -> min_v) return;",
			"        if (a <= l && r <= b && x < nd -> smin_v) {",
			"            nd -> update_min(x);",
			"            return;",
			"        }",
			"        nd -> push();",
			"        _update_max(x, a, b, nd ->  left, l, (l + r) >> 1);",
			"        _update_max(x, a, b, nd -> right, (l + r) >> 1, r);",
			"        nd -> update();",
			"    }",
			"",
			"    void _add_val(int_fast64_t x, int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a) return;",
			"        if (a <= l && r <= b) {",
			"            nd -> addall(x);",
			"            return;",
			"        }",
			"        nd -> push();",
			"        _add_val(x, a, b, nd ->  left, l, (l + r) >> 1);",
			"        _add_val(x, a, b, nd -> right, (l + r) >> 1, r);",
			"        nd -> update();",
			"    }",
			"",
			"    void _update_val(int_fast64_t x, int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a) return;",
			"        if (a <= l && r <= b) {",
			"            nd -> updateall(x);",
			"            return;",
			"        }",
			"        nd -> push();",
			"        _update_val(x, a, b, nd ->  left, l, (l + r) >> 1);",
			"        _update_val(x, a, b, nd -> right, (l + r) >> 1, r);",
			"        nd -> update();",
			"    }",
			"",
			"    int_fast64_t _query_max(int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a) return -INF;",
			"        if (a <= l && r <= b) return nd -> max_v;",
			"        nd -> push();",
			"        int_fast64_t lv = _query_max(a, b, nd ->  left, l, (l + r) >> 1);",
			"        int_fast64_t rv = _query_max(a, b, nd -> right, (l + r) >> 1, r);",
			"        return max(lv, rv);",
			"    }",
			"",
			"    int_fast64_t _query_min(int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a) return INF;",
			"        if (a <= l && r <= b) return nd -> min_v;",
			"        nd -> push();",
			"        int_fast64_t lv = _query_min(a, b, nd ->  left, l, (l + r) >> 1);",
			"        int_fast64_t rv = _query_min(a, b, nd -> right, (l + r) >> 1, r);",
			"        return min(lv, rv);",
			"    }",
			"",
			"    int_fast64_t _query_sum(int a, int b, Node *nd, int l, int r) {",
			"        if (b <= l || r <= a) return 0;",
			"        if (a <= l && r <= b) return nd -> sum;",
			"        nd -> push();",
			"        int_fast64_t lv = _query_sum(a, b, nd ->  left, l, (l + r) >> 1);",
			"        int_fast64_t rv = _query_sum(a, b, nd -> right, (l + r) >> 1, r);",
			"        return lv + rv;",
			"    }",
			"",
			"    SegmentTreeBeats(int n, int_fast64_t val = 0) : n(n) {",
			"        n0 = 1; while (n0 < n) n0 <<= 1;",
			"        Node *nds = new Node[2 * n0];",
			"        root = nds;",
			"        nds[0].len = n0;",
			"        for (int i = 0; i < n0 - 1; ++i) {",
			"            nds[i].left = &nds[2 * i + 1];",
			"            nds[i].right = &nds[2 * i + 2];",
			"            nds[2 * i + 1].len = nds[2 * i + 2].len = nds[i].len >> 1;",
			"        }",
			"        for (int i = 0; i <  n; ++i) nds[n0 - 1 + i].init(val);",
			"        for (int i = n; i < n0; ++i) nds[n0 - 1 + i].init_empty();",
			"        for (int i = n0 - 2; i >= 0; i--) nds[i].update();",
			"    }",
			"",
			"    SegmentTreeBeats(int n, vector<int_fast64_t> a) : n(n) {",
			"        n0 = 1; while (n0 < n) n0 <<= 1;",
			"        Node *nds = new Node[2 * n0];",
			"        root = nds;",
			"        nds[0].len = n0;",
			"        for (int i = 0; i < n0 - 1; ++i) {",
			"            nds[i].left = &nds[2 * i + 1];",
			"            nds[i].right = &nds[2 * i + 2];",
			"            nds[2 * i + 1].len = nds[2 * i + 2].len = nds[i].len >> 1;",
			"        }",
			"        assert(n == (int)a.size());",
			"        for (int i = 0; i <  n; ++i) nds[n0 - 1 + i].init(a[i]);",
			"        for (int i = n; i < n0; ++i) nds[n0 - 1 + i].init_empty();",
			"        for (int i = n0 - 2; i >= 0; i--) nds[i].update();",
			"    }",
			"",
			"    void update_min(int a, int b, int_fast64_t x) { _update_min(x, a, b, root, 0, n0); }",
			"    void update_max(int a, int b, int_fast64_t x) { _update_max(x, a, b, root, 0, n0); }",
			"    void    add_val(int a, int b, int_fast64_t x) {    _add_val(x, a, b, root, 0, n0); }",
			"    void update_val(int a, int b, int_fast64_t x) { _update_val(x, a, b, root, 0, n0); }",
			"    int_fast64_t query_max(int a, int b) { return _query_max(a, b, root, 0, n0); }",
			"    int_fast64_t query_min(int a, int b) { return _query_min(a, b, root, 0, n0); }",
			"    int_fast64_t query_sum(int a, int b) { return _query_sum(a, b, root, 0, n0); }",
			"};",
			"",
			"/*",
			"・Segment Tree Beats",
			"[備考] 任意の区間に対するchminクエリなどを, O(logN)で処理できるデータ構造",
			"[使用例]",
			"SegmentTreeBeats seg(N);",
			"seg.update_min(l, r, x);    // [l, r)をxにchmin",
			"seg.update_max(l, r, x);    // [l, r)をxにchmax",
			"seg.add_val(l, r, x);       // [l, r)にxを加算",
			"seg.update_val(l, r, x);    // [l, r)をxに変更",
			"seg.query_max(l, r);        // [l, r)の最大値",
			"seg.query_min(l, r);        // [l, r)の最小値",
			"seg.query_sum(l, r);        // [l, r)の総和",
			"[参考] https://gist.github.com/tjkendev/20e7f96b9262f7a5d739bdc978c075bd",
			"*/",
		],
	},
	"UnionFind木": {
		"prefix": [
			"data structure",
			"unionfind",
		],
		"body": [
			"struct UnionFind {",
			"    vector<int> parent;",
			"    int __size;",
			"    UnionFind(int size_) : parent(size_, -1), __size(size_) {}",
			"    bool unite(int x, int y) {",
			"        if ((x = find(x)) != (y = find(y))) {",
			"            if (parent[y] < parent[x]) swap(x, y);",
			"            parent[x] += parent[y];",
			"            parent[y] = x;",
			"            __size--;",
			"            return true;",
			"        }",
			"        return false;",
			"    }",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"    int find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }",
			"    int size(int x) { return -parent[find(x)]; }",
			"    int size() { return __size; }",
			"};",
			"",
			"/*",
			"・UnionFind木",
			"    > O(α(n))",
			"[使用例]",
			"UnionFind uf(V);    // 頂点数VのUnionFind木を宣言",
			"uf.unite(a, b);     // 点a, b([0, n))が同じ集合に属する (すでに同じだったらfalseを返す)",
			"uf.same(a, b);      // 点a, bが同じ集合に属するか確認",
			"uf.find(a);         // 点aが属する集合を求める",
			"uf.size(a);         // 点aが属する集合の要素の数を求める",
			"*/",
		],
	},
	"重み付きUnionFind木": {
		"prefix": [
			"data structure",
			"unionfind",
			"omomituki unionfind",
		],
		"body": [
			"template<typename T> struct WeightedUnionFind {",
			"    vector<int> parent, rank;",
			"    vector< T > diff_weight;",
			"    WeightedUnionFind(int n = 1, T SUM_UNITY = 0) { init(n, SUM_UNITY); }",
			"    void init(int n = 1, T SUM_UNITY = 0) {",
			"        parent.resize(n); rank.resize(n); diff_weight.resize(n);",
			"        for (int i = 0; i < n; ++i) parent[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;",
			"    }",
			"    int find(int x) {",
			"        if (parent[x] == x) return x;",
			"        int ret = find(parent[x]);",
			"        diff_weight[x] += diff_weight[parent[x]];",
			"        return parent[x] = ret;",
			"    }",
			"    bool unite(int x, int y, T w) {",
			"        w += weight(x); w -= weight(y);",
			"        x = find(x);    y = find(y);",
			"        if (x == y) return false;",
			"        if (rank[x] <  rank[y]) swap(x, y), w = -w;",
			"        if (rank[x] == rank[y]) ++rank[x];",
			"        parent[y] = x;",
			"        diff_weight[y] = w;",
			"        return true;",
			"    }",
			"    T weight(int x) { find(x); return diff_weight[x]; }",
			"    T diff(int x, int y) { return weight(y) - weight(x); }",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"};",
			"",
			"/*",
			"・重み付きUnionFind木",
			"    > O(α(n))",
			"[使用例]",
			"WeightedUnionFind uf(V);    // 頂点数Vの重み付きUnionFind木を宣言",
			"uf.unite(a, b, w);          // 点a, b([0, n))が同じ集合に属し, それらの間の重みがwである (すでに同じだったらfalseを返す)",
			"uf.same(a, b);              // 点a, bが同じ集合に属するか確認",
			"uf.find(a);                 // 点aが属する集合を求める",
			"uf.diff(a, b);              // 点a, bの間の重みを求める",
			"*/",
		],
	},
	"Binary Indexed Tree": {
		"prefix": [
			"data structure",
			"binary indexed tree",
		],
		"body": [
			"template<typename T> struct BinaryIndexedTree {",
			"    vector< T > data;",
			"    BinaryIndexedTree(int sz) { data.assign(++sz, 0); }",
			"    T sum(int k) {",
			"        if (k < 0) return T(0);",
			"        T ret = 0;",
			"        for (++k; k > 0; k -= k & -k) ret += data[k];",
			"        return (ret);",
			"    }",
			"    T sum(int l, int r) {",
			"        assert(l <= r);",
			"        return sum(r - 1) - sum(l - 1);",
			"    }",
			"    void add(int k, T x) {",
			"        for (++k; k < data.size(); k += k & -k) data[k] += x;",
			"    }",
			"};",
			"",
			"/*",
			"・Binary Indexed Tree (Fenwick Tree)",
			"    > O(logN)",
			"[備考] ある要素に値を加える操作と, 区間和を求める操作に関してlogNで行うデータ構造",
			"[使用例]",
			"BinaryIndexedTree<int> bit(N);      // 要素数NのBIT",
			"bit.add(k, x);                      // 要素kに値xを加算",
			"bit.sum(k);                         // 閉区間[0, k]の和を求める",
			"bit.sum(l, r);                      // 半開区間[l, r)の和を求める",
			"*/",
		],
	},
	"Segment Map": {
		"prefix": [
			"data structure",
			"segment map",
			"map",
		],
		"body": [
			"class SegmentMap : public map<int_fast64_t, int_fast64_t> {",
			"	bool flagToMergeAdjacentSegment;",
			"	SegmentMap(bool flagToMergeAdjacentSegment) : flagToMergeAdjacentSegment(flagToMergeAdjacentSegment) {}",
			"	auto get(int_fast64_t p) const {",
			"		auto it = upper_bound(p);",
			"		if (it == begin() or (--it)->second < p) return end();",
			"		return it;",
			"	}",
			"	void insert(int_fast64_t l, int_fast64_t r) {",
			"		auto itl = upper_bound(l), itr = upper_bound(r + flagToMergeAdjacentSegment);",
			"		if (itl != begin()) {",
			"			if ((--itl)->second < l - flagToMergeAdjacentSegment) ++itl;",
			"		}",
			"		if (itl != itr) {",
			"			l = min(l, itl->first);",
			"			r = max(r, prev(itr)->second);",
			"			erase(itl, itr);",
			"		}",
			"		(*this)[l] = r;",
			"	}",
			"	void remove(int_fast64_t l, int_fast64_t r) {",
			"		auto itl = upper_bound(l), itr = upper_bound(r);",
			"		if (itl != begin()) {",
			"			if ((--itl)->second < l) ++itl;",
			"		}",
			"		if (itl == itr) return;",
			"		int tl = min(l, itl->first), tr = max(r, prev(itr)->second);",
			"		erase(itl, itr);",
			"		if (tl < l) (*this)[tl] = l - 1;",
			"		if (r < tr) (*this)[r + 1] = tr;",
			"	}",
			"	bool same(int_fast64_t p, int_fast64_t q) const {",
			"		const auto&& it = get(p);",
			"		return it != end() and it->first <= q and q <= it->second;",
			"	}",
			"};",
			"",
			"/*",
			"・SegmentMap",
			"[備考] 区間をmapで管理するやつ",
			"[注意] 以下で扱う区間は全て閉区間",
			"[使用例]",
			"SegmentMap mp(flag);    // flagがtrueなら, [l, c]と[c + 1, r]をマージする",
			"mp.get(p);              // pを含む区間を返す(存在しないならmp.end())",
			"mp.insert(l, r);        // 閉区間[l, r]を追加する",
			"mp.remove(l, r);        // 閉区間[l, r]を取り除く",
			"mp.same(p, q);          // 2点p, qが同じ区間にあればtrue",
			"*/",
		],
	},
	"Sparse Table": {
		"prefix": [
			"data structure",
			"sparse table",
		],
		"body": [
			"template<typename T> struct SparseTable {",
			"    vector< vector< T > > st;",
			"    SparseTable() {}",
			"    SparseTable(const vector< T > &v) {",
			"        int b = 0;",
			"        while ((1 << b) <= v.size()) ++b;",
			"        st.assign(b, vector< T >(1LL << b));",
			"        for (int i = 0; i < v.size(); ++i) st[0][i] = v[i];",
			"        for (int i = 1; i < b; ++i) {",
			"            for (int j = 0; j + (1LL << i) <= (1LL << b); ++j) {",
			"                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1LL << (i - 1))]);",
			"            }",
			"        }",
			"    }",
			"    inline T query(int l, int r) {",
			"        int b = 32 - __builtin_clz(r - l) - 1;",
			"        return (min(st[b][l], st[b][r - (1LL << b)]));",
			"    }",
			"};",
			"",
			"/*",
			"・SparseTable",
			"    > 前処理 O(NlogN)",
			"    > query O(1)",
			"[備考] 静的な配列における, 任意区間の最小値を定数時間で求められるデータ構造.",
			"[使用例]",
			"SparseTable<int> st(V);     // V(vector<int>)で初期化し, 前処理を行う",
			"st.query(l, r);             // 半開区間[l, r)における最小値",
			"*/",
		],
	},
	"Wavelet Matrix": {
		"prefix": [
			"data structure",
			"wavelet matrix",
		],
		"body": [
			"struct FullyIndexableDictionary {",
			"    int len, blk;",
			"    vector<unsigned> bit;",
			"    vector<int> sum;",
			"    FullyIndexableDictionary() {}",
			"    FullyIndexableDictionary(int len) : len(len), blk((len + 31) >> 5), bit(blk, 0), sum(blk, 0) {}",
			"    void set(int k) {",
			"        bit[k >> 5] |= 1u << (k & 31);",
			"    }",
			"    void build() {",
			"        sum[0] = 0;",
			"        for (int i = 1; i < blk; ++i) sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]);",
			"    }",
			"    bool operator[](int k) const {",
			"        return bool((bit[k >> 5] >> (k & 31)) & 1);",
			"    }",
			"    int rank(int k) {",
			"        return sum[k >> 5] + __builtin_popcount(bit[k >> 5] & ((1u << (k & 31)) - 1));",
			"    }",
			"    int rank(bool v, int k) {",
			"        return (v ? rank(k) : k - rank(k));",
			"    }",
			"    int select(bool v, int k) {",
			"        if (k < 0 or rank(v, len) <= k) return -1;",
			"        int l = 0, r = len;",
			"        while (l + 1 < r) {",
			"            int m = (l + r) >> 1;",
			"            if (rank(v, m) >= k + 1) r = m;",
			"            else l = m;",
			"        }",
			"        return r - 1;",
			"    }",
			"    int select(bool v, int i, int l) {",
			"        return select(v, i + rank(v, l));",
			"    }",
			"};",
			"template<typename T, int MAXLOG> struct WaveletMatrix {",
			"    int len;",
			"    FullyIndexableDictionary mat[MAXLOG];",
			"    int zs[MAXLOG], buff1[MAXLOG], buff2[MAXLOG];",
			"    static const T npos = -1;",
			"",
			"    int freq_dfs(int d, int l, int r, T val, T a, T b) {",
			"        if (l == r) return 0;",
			"        if (d == MAXLOG) return (a <= val and val < b) ? r - l : 0;",
			"        T nv = T(1) << (MAXLOG - d - 1) | val;",
			"        T nnv = ((T(1) << (MAXLOG - d - 1)) - 1) | nv;",
			"        if (nnv < a or b <= val) return 0;",
			"        if (a <= val and nnv < b) return r - l;",
			"        int lc = mat[d].rank(1, l), rc = mat[d].rank(1, r);",
			"        return freq_dfs(d + 1, l - lc, r - rc, val, a, b) + freq_dfs(d + 1, lc + zs[d], rc + zs[d], nv, a, b);",
			"    }",
			"    WaveletMatrix(vector< T > data) {",
			"        len = data.size();",
			"        vector< T > l(len), r(len);",
			"        for (int dep = 0; dep < MAXLOG; ++dep) {",
			"            mat[dep] = FullyIndexableDictionary(len + 1);",
			"            int p = 0, q = 0;",
			"            for (int i = 0; i < len; ++i) {",
			"                bool k = (data[i] >> (MAXLOG - (dep + 1))) & 1;",
			"                if (k) r[q++] = data[i], mat[dep].set(i);",
			"                else  l[p++] = data[i];",
			"            }",
			"            zs[dep] = p;",
			"            mat[dep].build();",
			"            swap(l, data);",
			"            for (int i = 0; i < q; ++i) data[p + i] = r[i];",
			"        }",
			"    }",
			"    T access(int k) {",
			"        T res = 0;",
			"        for (int dep = 0; dep < MAXLOG; ++dep) {",
			"            bool bit = mat[dep][k];",
			"            res = (res << 1) | bit;",
			"            k = mat[dep].rank(bit, k) + zs[dep] * dep;",
			"        }",
			"        return res;",
			"    }",
			"    int rank(T v, int k) {",
			"        int l = 0, r = k;",
			"        for (int dep = 0; dep < MAXLOG; ++dep) {",
			"            buff1[dep] = l; buff2[dep] = r;",
			"            bool bit = (v >> (MAXLOG - (dep + 1))) & 1;",
			"            l = mat[dep].rank(bit, l) + zs[dep] * bit;",
			"            r = mat[dep].rank(bit, r) + zs[dep] * bit;",
			"        }",
			"        return r - l;",
			"    }",
			"    int select(T v, int k) {",
			"        rank(v, len);",
			"        for (int dep = MAXLOG - 1; dep >= 0; --dep) {",
			"            bool bit = (v >> (MAXLOG - (dep + 1))) & 1;",
			"            k = mat[dep].select(bit, k, buff1[dep]);",
			"            if (k >= buff2[dep] or k < 0) return -1;",
			"            k -= buff1[dep];",
			"        }",
			"        return k;",
			"    }",
			"    int select(T v, int k, int l) {",
			"        return select(v, k + rank(v, l));",
			"    }",
			"    T quantile(int l, int r, int k) {",
			"        if (r - l <= k or k < 0) return -1;",
			"        T res = 0;",
			"        for (int dep = 0; dep < MAXLOG; ++dep) {",
			"            int p = mat[dep].rank(1, l);",
			"            int q = mat[dep].rank(1, r);",
			"            if (q - p > k) {",
			"                l = p + zs[dep];",
			"                r = q + zs[dep];",
			"                res |= T(1) << (MAXLOG - (dep + 1));",
			"            } else {",
			"                k -= (q - p);",
			"                l -= p;",
			"                r -= q;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    T rquantile(int l, int r, int k) {",
			"        return quantile(l, r, r - l - k - 1);",
			"    }",
			"    int rangefreq(int left, int right, T lower, T upper) {",
			"        return freq_dfs(0, left, right, 0, lower, upper);",
			"    }",
			"    pair<int, int> ll(int l, int r, T v) {",
			"        int res = 0;",
			"        for (int dep = 0; dep < MAXLOG; ++dep) {",
			"            buff1[dep] = l; buff2[dep] = r;",
			"            bool bit = (v >> (MAXLOG - (dep + 1))) & 1;",
			"            if (bit) res += r - l + mat[dep].rank(bit, l) - mat[dep].rank(bit, r);",
			"            l = mat[dep].rank(bit, l) + zs[dep] * bit;",
			"            r = mat[dep].rank(bit, r) + zs[dep] * bit;",
			"        }",
			"        return make_pair(res, r - l);",
			"    }",
			"    int lt(int l, int r, T v) {",
			"        auto p = ll(l, r, v);",
			"        return p.first;",
			"    }",
			"    int le(int l, int r, T v) {",
			"        auto p = ll(l, r, v);",
			"        return p.first + p.second;",
			"    }",
			"    T succ(int l, int r, T v) {",
			"        int k = le(l, r, v);",
			"        return k == r - l ? npos : rquantile(l, r, k);",
			"    }",
			"    T pred(int l, int r, T v) {",
			"        int k = lt(l, r, v);",
			"        return k ? rquantile(l, r, k - 1) : npos;",
			"    }",
			"};",
			"",
			"/*",
			"・WaveletMatrix",
			"[備考]",
			"[使用例]",
			"WaveletMatrix<int, 32> wm(V);   // 最大の要素が2^32未満であるV(vector<int>)から構築",
			"wm.rank(v, k);                  // 半開区間[0, k)にvが何個あるかを返す",
			"wm.select(v, k);                // k個目のvのindexを返す",
			"wm.quantile(l, r, k);           // 半開区間[l, r)において, k番目に大きい数を返す",
			"wm.rangefreq(l, r, mn, mx);     // 半開区間[l, r)において, 半開区間[mn, mx)に含まれる数の個数を返す",
			"[ToDo] topk, intersect (http://miti-7.hatenablog.com/entry/2018/04/28/152259)",
			"*/",
		],
	},
	"グラフの宣言": {
		"prefix": [
			"graph",
		],
		"body": [
			"template<typename T> struct Edge {",
			"    int from, to;",
			"    T weight;",
			"    Edge() : from(0), to(0), weight(0) {}",
			"    Edge(int f, int t, T w) : from(f), to(t), weight(w) {}",
			"};",
			"template<typename T> using Edges = vector< Edge< T > >;",
			"template<typename T> using Graph = vector< Edges< T > >;",
			"template<typename T> void     add_edge(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from, to, w); g[to].emplace_back(to, from, w); }",
			"template<typename T> void      add_arc(Graph< T > &g, int from, int to, T w = 1) { g[from].emplace_back(from, to, w); }",
			"template<typename T> void add_to_edges(Edges< T > &e, int from, int to, T w = 1) { e.emplace_back(from, to, w); }",
			"",
			"/*",
			"・グラフ用テンプレート",
			"    > Dijkstra",
			"    > BellmanFord",
			"    > WarshallFloyd",
			"    > Kruskal",
			"[応用] 単一終点最短路問題は, すべての有向辺を逆向きに張り替えると, 単一始点最短路問題に帰着できる.",
			"[使用例]",
			"Graph<int> g(V);                // 頂点数V, 重さの型がintのグラフを宣言",
			"add_edge(g, a, b, c);           // グラフgに, 始点a, 終点b, 重さcの無向辺を追加",
			"add_arc(g, a, b, c);            // グラフgに, 始点a, 終点b, 重さcの有向辺を追加",
			"add_to_edges(edges, a, b, c);   // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加",
			"*/",
		],
	},
	"二部グラフの判定": {
		"prefix": [
			"graph",
			"bipartite",
			"nibugurahu",
		],
		"body": [
			"template <typename T> bool isBipartiteGraph(const Graph< T > &g) {",
			"    int V = g.size();",
			"    vector<int> color(V, 0);",
			"    bool ret = true;",
			"    function<void(int, int)> dfs = [&](int i, int clr) {",
			"        if (color[i] != 0) return;",
			"        color[i] = clr;",
			"        for (auto& e: g[i]) {",
			"            if (color[e.to] == 0) dfs(e.to, -clr);",
			"            else if (color[e.to] == clr) ret = false;",
			"        }",
			"    };",
			"    dfs(0, 1);",
			"    return ret;",
			"    int cnt = 0;",
			"    for (auto& e: color) if (e == 1) ++cnt;",
			"    return ret ? -1 : cnt;",
			"}",
			"",
			"/*",
			"・二部グラフの判定",
			"    > O(E+V) [E:辺の数, V:頂点の数]",
			"[備考] 二部グラフならtrueを返す.",
			"[使用例] isBipartiteGraph(g);",
			"[その他] 二部グラフだった際に, 片方の集合の大きさが知りたい場合は, return retを削除して, intを返すようにする.",
			"        その場合は, 二部グラフならばその集合の大きさを, そうでない場合は-1を返す.",
			"*/",
		],
	},
	"二部グラフの最大マッチング": {
		"prefix": [
			"graph",
			"bipartite",
			"nibugurahu",
			"matching",
		],
		"body": [
			"struct Bipartite_Matching {",
			"    vector<vector<int>> graph;",
			"    vector<int> match, alive, used;",
			"    int timestamp;",
			"",
			"    Bipartite_Matching(int n) : timestamp(0) {",
			"        graph.resize(n);",
			"        alive.assign(n, 1);",
			"        used.assign(n, 0);",
			"        match.assign(n, -1);",
			"    }",
			"",
			"    void add_edge(int u, int v) {",
			"        graph[u].push_back(v);",
			"        graph[v].push_back(u);",
			"    }",
			"",
			"    bool dfs(int v) {",
			"        used[v] = timestamp;",
			"        for (int i = 0; i < graph[v].size(); i++) {",
			"            int u = graph[v][i], w = match[u];",
			"            if (alive[u] == 0) continue;",
			"            if (w == -1 || (used[w] != timestamp && dfs(w))) {",
			"                match[v] = u;",
			"                match[u] = v;",
			"                return true;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    int bipartite_matching() {",
			"        int ret = 0;",
			"        for (int i = 0; i < graph.size(); i++) {",
			"            if (alive[i] == 0) continue;",
			"            if (match[i] == -1) {",
			"                ++timestamp;",
			"                ret += dfs(i);",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"",
			"/*",
			"・二部グラフの最大マッチング",
			"    > O(E * V) [E:辺の数, V:頂点の数]",
			"[備考] 最大流のアルゴリズムを用いて求める.",
			"[応用] 最大マッチングは, 最小点被覆と一致(Mとおく).",
			"      最大安定集合(最大独立集合)は, 最小辺被覆と(V - M)で一致.",
			"[参考] https://qiita.com/drken/items/e805e3f514acceb87602",
			"      https://qiita.com/drken/items/7f98315b56c95a6181a4",
			"[使用例]",
			"Bipartite_Matching bip(N);      // 頂点数Nのグラフを用意.",
			"bip.add_edge(from, to);         // 頂点fromから頂点toへの有向辺を足す.",
			"bip.bipartite_matching();       // 最大マッチングを求める.",
			"*/",
		],
	},
	"最大流 Dinic O(EV^2)": {
		"prefix": [
			"graph",
			"dinic",
			"maximum flow",
			"flow",
		],
		"body": [
			"template<typename T> struct Dinic {",
			"    struct edge {",
			"        int to;",
			"        T cap;",
			"        int rev;",
			"    };",
			"    const T INF;",
			"    vector< vector< edge > > graph;",
			"    vector< T > min_cost;",
			"    vector<int> iter;",
			"    Dinic(int n) : INF(numeric_limits< T >::max()) { graph.resize(n); }",
			"    void add_edge(int from, int to, T cap) {",
			"        graph[from].push_back((edge) {to, cap, (int) graph[  to].size()});",
			"        graph[  to].push_back((edge) {from, 0, (int) graph[from].size() - 1});",
			"    }",
			"    bool bfs(int s, int t) {",
			"        min_cost.assign(graph.size(), -1);",
			"        queue<int> que;",
			"        min_cost[s] = 0;",
			"        que.push(s);",
			"        while (not que.empty()) {",
			"            int p = que.front(); que.pop();",
			"            for (auto &e : graph[p]) {",
			"                if (e.cap > 0 and min_cost[e.to] == -1) {",
			"                    min_cost[e.to] = min_cost[p] + 1;",
			"                    que.push(e.to);",
			"                }",
			"            }",
			"        }",
			"        return (min_cost[t] != -1);",
			"    }",
			"    T dfs(int idx, const int t, T flow) {",
			"        if (idx == t) return flow;",
			"        for (int &i = iter[idx]; i < (int)graph[idx].size(); ++i) {",
			"            edge &e = graph[idx][i];",
			"            if (e.cap > 0 and min_cost[idx] < min_cost[e.to]) {",
			"                T d = dfs(e.to, t, min(flow, e.cap));",
			"                if (d > 0) {",
			"                    e.cap -= d;",
			"                    graph[e.to][e.rev].cap += d;",
			"                    return d;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    T max_flow(int s, int t) {",
			"        T flow = 0;",
			"        while (bfs(s, t)) {",
			"            iter.assign(graph.size(), 0);",
			"            T f = 0;",
			"            while ((f = dfs(s, t, INF)) > 0) {",
			"                flow += f;",
			"            }",
			"        }",
			"        return flow;",
			"    }",
			"};",
			"",
			"/*",
			"・Dinic法",
			"    > O(E * V ^ 2) [E:辺の数, V:頂点の数]",
			"[備考] 最大流を求めるアルゴリズム.",
			"      最大流は最小カットと一致する(最大フロー最小カット定理).",
			"      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.",
			"[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336",
			"[使用例]",
			"Dinic<int> dnc(N);                // 頂点数Nのグラフを用意.",
			"dnc.add_edge(from, to, cap);      // 頂点fromから頂点toへ容量capの有向辺を足す.",
			"dnc.max_flow(s, t);               // 頂点sから頂点tまでの最大流.",
			"*/",
		],
	},
	"最大流 FordFulkerson O(EF)": {
		"prefix": [
			"graph",
			"fordfulkerson",
			"maximum flow",
			"flow",
		],
		"body": [
			"template<typename T> struct FordFulkerson {",
			"    struct edge {",
			"        int to;",
			"        T cap;",
			"        int rev;",
			"    };",
			"    vector< vector< edge > > graph;",
			"    vector<int> used;",
			"    const T INF;",
			"    int timestamp;",
			"    FordFulkerson(int n) : INF(numeric_limits< T >::max()), timestamp(0) {",
			"        graph.resize(n);",
			"        used.assign(n, -1);",
			"    }",
			"    void add_edge(int from, int to, T cap) {",
			"        graph[from].emplace_back((edge) {to, cap, (int)graph[  to].size()});",
			"        graph[  to].emplace_back((edge) {from, 0, (int)graph[from].size() - 1});",
			"    }",
			"    T dfs(int idx, const int t, T flow) {",
			"        if (idx == t) return flow;",
			"        used[idx] = timestamp;",
			"        for (auto &e : graph[idx]) {",
			"            if (e.cap > 0 and used[e.to] != timestamp) {",
			"                T d = dfs(e.to, t, min(flow, e.cap));",
			"                if (d > 0) {",
			"                    e.cap -= d;",
			"                    graph[e.to][e.rev].cap += d;",
			"                    return d;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"    T max_flow(int s, int t) {",
			"        T flow = 0;",
			"        for (T f; (f = dfs(s, t, INF)) > 0; timestamp++) flow += f;",
			"        return flow;",
			"    }",
			"};",
			"",
			"/*",
			"・Ford-Fulkerson法",
			"    > O(EF) [E:辺の数, F:最大フロー]",
			"[備考] 最大流を求めるアルゴリズム.",
			"      最大流は最小カットと一致する(最大フロー最小カット定理).",
			"      「燃やす埋める問題」や「全ての頂点を二色に塗り分ける問題」などは最小カットに帰着できる.",
			"[参考] http://yosupo.hatenablog.com/entry/2015/03/31/134336",
			"[使用例]",
			"FordFulkerson<int> ff(N);         // 頂点数Nのグラフを用意.",
			"ff.add_edge(from, to, cap);       // 頂点fromから頂点toへ容量capの有向辺を足す.",
			"ff.max_flow(s, t);                // 頂点sから頂点tへの最大流.",
			"*/",
		],
	},
	"最小費用流 PrimalDual O(FElogV)": {
		"prefix": [
			"graph",
			"primal dual",
			"min cost flow",
			"flow",
		],
		"body": [
			"struct PrimalDual {",
			"    const int INF = 1 << 30;",
			"    typedef pair<int, int> P;",
			"    struct edge {",
			"        int to, cap, cost, rev;",
			"    };",
			"    vector< vector< edge > > graph;",
			"    vector< int > potential, min_cost, prevv, preve;",
			"    PrimalDual(int V) : graph(V) {}",
			"    void add_edge(int from, int to, int cap, int cost) {",
			"        graph[from].push_back((edge) {to, cap,  cost, (int)graph[to].size()});",
			"        graph[  to].push_back((edge) {from, 0, -cost, (int)graph[from].size() - 1});",
			"    }",
			"    int min_cost_flow(int s, int t, int f) {",
			"        int V = graph.size(), ret = 0;",
			"        priority_queue< P, vector< P >, greater< P > > que;",
			"        potential.assign(V, 0);",
			"        preve.assign(V, -1);",
			"        prevv.assign(V, -1);",
			"        while (f > 0) {",
			"            min_cost.assign(V, INF);",
			"            que.push(P(0, s));",
			"            min_cost[s] = 0;",
			"            while (not que.empty()) {",
			"                P p = que.top(); que.pop();",
			"                if (min_cost[p.second] < p.first) continue;",
			"                for (int i = 0; i < (int)graph[p.second].size(); i++) {",
			"                    edge &e = graph[p.second][i];",
			"                    int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];",
			"                    if (e.cap > 0 and min_cost[e.to] > nextCost) {",
			"                        min_cost[e.to] = nextCost;",
			"                        prevv[e.to] = p.second, preve[e.to] = i;",
			"                        que.push(P(min_cost[e.to], e.to));",
			"                    }",
			"                }",
			"            }",
			"            if (min_cost[t] == INF) return -1;",
			"            for (int v = 0; v < V; v++) potential[v] += min_cost[v];",
			"            int addflow = f;",
			"            for (int v = t; v != s; v = prevv[v]) {",
			"                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);",
			"            }",
			"            f -= addflow;",
			"            ret += addflow * potential[t];",
			"            for (int v = t; v != s; v = prevv[v]) {",
			"                edge &e = graph[prevv[v]][preve[v]];",
			"                e.cap -= addflow;",
			"                graph[v][e.rev].cap += addflow;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"",
			"/*",
			"・最小費用流",
			"    > O(FElogV) [E:辺の数, V:頂点の数]",
			"[備考] 最小費用流を求めるアルゴリズム.",
			"[参考] 辺の数が多い場合は, O(UCV^2) [U:容量合計, C:費用合計] のアルゴリズムもある.",
			"        (http://www.prefield.com/algorithm/graph/primal_dual.html)",
			"[使用例]",
			"Primal_Dual pd(N);                  // 頂点数Nのグラフを用意.",
			"pd.add_edge(from, to, cap, cost);   // 頂点fromから頂点toへ, 容量cap, 単位コストcostの有向辺を用意.",
			"pd.min_cost_flow(from, to, flow);   // 頂点fromから頂点toへ, 流量flowを流す際のコスト.",
			"*/",
		],
	},
	"最小全域木 Kruskal O(ElogV)": {
		"prefix": [
			"graph",
			"kruskal",
			"tree",
			"minimim spanning tree",
		],
		"body": [
			"template<typename T> T Kruskal(Edges< T > &edges, int V) {",
			"    sort(begin(edges), end(edges), [](const Edge< T > &a, const Edge< T > &b) {",
			"        return (a.weight < b.weight);",
			"    });",
			"    UnionFind tree(V);",
			"    T ret = 0;",
			"    for (auto &e : edges) if (tree.unite(e.from, e.to)) ret += e.weight;",
			"    return ret;",
			"}",
			"",
			"/*",
			"・Kruskal法",
			"    > O(ElogV) [E:辺の数, V:頂点の数]",
			"[備考] 最小全域木を求めるアルゴリズム.",
			"      UnionFindで, 閉路を作らないように辺を重みが小さい順に加えていく.",
			"[注意] UnionFindを上で定義しておくこと.",
			"[使用例]",
			"Edges<int> edges;           // 全ての辺 (重さ: int)",
			"add_to_edges(edges,a,b,c);  // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加",
			"Kruskal(edges,V);           // 辺edges, 頂点数Vのグラフにおける最小全域木の重さ",
			"*/",
		],
	},
	"トポロジカルソート O(E + V)": {
		"prefix": [
			"graph",
			"topological sort",
		],
		"body": [
			"template<typename T> bool TopologicalSort(const Graph< T > &g, vector<int> &order) {",
			"    int V = g.size();",
			"    vector<int> color(V);",
			"    function<bool(int)> visit = [&](int v) {",
			"        color[v] = 1;",
			"        for (auto& e: g[v]) {",
			"            if (color[e.to] == 2) continue;",
			"            if (color[e.to] == 1) return false;",
			"            if (!visit(e.to)) return false;",
			"        }",
			"        order.push_back(v); color[v] = 2;",
			"        return true;",
			"    };",
			"    for (int i = 0; i < V; ++i) if (!color[i] and !visit(i)) return false;",
			"    reverse(order.begin(), order.end());",
			"    return true;",
			"}",
			"",
			"/*",
			"・トポロジカルソート",
			"    > O(E + V) [E:辺の数, V:頂点の数]",
			"[備考] グラフの位相的順序を求める.",
			"[使用例]",
			"vector<int> ts;             // トポロジカルソートの結果を格納するvector.",
			"TopologicalSort(g, ts);     // グラフgのトポロジカルソートの結果をtsに格納. 返り値はトポロジカルソート可能か否か.",
			"*/",
		],
	},
	"BellmanFord O(EV)": {
		"prefix": [
			"graph",
			"bellmanford",
		],
		"body": [
			"template<typename T> vector< T > BellmanFord(Edges< T > &edges, int vertex, int from) {",
			"    const auto INF = numeric_limits< T >::max() / 10;",
			"    vector< T > dist(vertex, INF);",
			"    dist[from] = 0;",
			"    for (int i = 0; i < vertex - 1; ++i) {",
			"        for (auto &e : edges) {",
			"            if (dist[e.from] == INF) continue;",
			"            dist[e.to] = min(dist[e.to], dist[e.from] + e.weight);",
			"        }",
			"    }",
			"    for (auto &e : edges) {",
			"        if (dist[e.from] == INF) continue;",
			"        if (dist[e.from] + e.weight < dist[e.to]) return vector< T >();",
			"    }",
			"    return dist;",
			"}",
			"",
			"/*",
			"・ベルマンフォード法",
			"    > O(E * V) [E:辺の数, V:頂点の数]",
			"[備考] グラフ(負辺が存在してもよい)に対する単一始点全点間最短路を求めるアルゴリズム",
			"      負閉路が存在しているかの判定も可能 -> 存在していたら空列を返す",
			"[注意] 結果を足し合わせる際, INFの大きさに注意",
			"[使用例]",
			"Edges<int> edges;                       // 全ての辺 (重さ: int)",
			"add_to_edges(edges, a, b, c);           // 辺集合edgesに, 始点a, 終点b, 重さcの辺を追加",
			"auto bf = BellmanFord(edges, V, s);     // 辺edges, 頂点数Vのグラフにおける, 始点sからの最短路",
			"*/",
		],
	},
	"Dijkstra O(ElogV)": {
		"prefix": [
			"graph",
			"dijkstra",
		],
		"body": [
			"template<typename T> vector< T > Dijkstra(Graph< T > &g, int from) {",
			"    const auto INF = numeric_limits< T >::max() / 10;",
			"    vector< T > dist(g.size(), INF);",
			"    dist[from] = 0;",
			"    using P = pair< T, int >;",
			"    priority_queue< P, vector< P >, greater< P > > que;",
			"    que.emplace(dist[from], from);",
			"    while (not que.empty()) {",
			"        T weight; int idx;",
			"        tie(weight, idx) = que.top(); que.pop();",
			"        if (dist[idx] < weight) continue;",
			"        for (auto &e : g[idx]) {",
			"            auto next_weight = weight + e.weight;",
			"            if (dist[e.to] <= next_weight) continue;",
			"            dist[e.to] = next_weight;",
			"            que.emplace(dist[e.to], e.to);",
			"        }",
			"    }",
			"    return dist;",
			"}",
			"",
			"/*",
			"・ダイクストラ法",
			"    > O(ElogV) [E:辺の数, V:頂点の数]",
			"[備考] 負辺の存在しないグラフに対する単一始点全点間最短路を求めるアルゴリズム",
			"[注意] 結果を足し合わせる際, INFの大きさに注意",
			"[使用例] auto dij = Dijkstra(g, s);     // グラフgにおける, 始点sからの最短路",
			"*/",
		],
	},
	"WarshallFloyd O(V^3)": {
		"prefix": [
			"graph",
			"warshallfloyd",
		],
		"body": [
			"template<typename T> using Matrix = vector< vector< T > >;",
			"template<typename T> Matrix< T > WarshallFloyd(Graph< T > &g) {",
			"    const auto INF = numeric_limits< T >::max() / 10;",
			"    int vertex = g.size();",
			"    Matrix< T > dist(vertex, vector< T >(vertex, INF));",
			"    for (int i = 0; i < vertex; ++i) dist[i][i] = 0;",
			"    for (int i = 0; i < vertex; ++i) {",
			"        for (auto &e : g[i]) {",
			"            dist[e.from][e.to] = min(dist[e.from][e.to], e.weight);",
			"        }",
			"    }",
			"    for (int k = 0; k < vertex; ++k) {",
			"        for (int i = 0; i < vertex; ++i) {",
			"            for (int j = 0; j < vertex; ++j) {",
			"                if (dist[i][k] != INF and dist[k][j] != INF) {",
			"                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    return dist;",
			"}",
			"template<typename T> void add_edge_to_matrix(Matrix< T > &mat, int from, int to, T weight = 1) {",
			"    const auto INF = numeric_limits< T >::max() / 10;",
			"    mat[from][to] = mat[to][from] = min(mat[from][to], weight);",
			"    int vertex = mat.size();",
			"    for (int k : {from, to}) {",
			"        for (int i = 0; i < vertex; ++i) {",
			"            for (int j = 0; j < vertex; ++j) {",
			"                if (mat[i][k] != INF and mat[k][j] != INF) {",
			"                    mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"/*",
			"・ワーシャルフロイド法",
			"    > O(V ^ 3) [V:頂点数] : 全点間最短路 (WarshallFloyd())",
			"    > O(V ^ 2)           : 辺の追加 (add_edge_to_matrix())",
			"[備考] 全点間最短路を求めるアルゴリズム",
			"      負閉路が存在しているかの検出も可能",
			"        -> ある頂点vからv自身への最短路が負なら負閉路が存在",
			"[注意] 結果を足し合わせる際, INFの大きさに注意",
			"[使用例]",
			"auto wf = WarshallFloyd(g);         // グラフgにおける全点間最短路",
			"add_edge_to_matrix(wf, a, b, c);    // 隣接行列wfに, 始点a, 終点b, 重さcの辺を追加して, wfを更新",
			"*/",
		],
	},
	"組み合わせ (逆元)": {
		"prefix": [
			"math",
			"combination",
			"inverse",
		],
		"body": [
			"constexpr bool EXPAND_TO_MINUS = true;",
			"constexpr int MOD = (int)1e9 + 7;",
			"constexpr int MAX_N = 2020202;",
			"uint_fast64_t fac[MAX_N], finv[MAX_N], inv[MAX_N];",
			"void COMinit() {",
			"    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;",
			"    for (int i = 2; i < MAX_N; ++i) {",
			"        fac[i] = fac[i - 1] * i % MOD;",
			"        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;",
			"        finv[i] = finv[i - 1] * inv[i] % MOD;",
			"    }",
			"}",
			"uint_fast64_t C(int n, int r) {",
			"    if (n < r or r < 0) return 0;",
			"    if (n < 0) return EXPAND_TO_MINUS ? ((r % 2 ? -1 : 1) * C(-n + r - 1, r)) : 0;",
			"    return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;",
			"}",
			"uint_fast64_t P(int n, int r) {",
			"    if (n < r or r < 0) return 0;",
			"    return fac[n] * finv[n - r] % MOD;",
			"}",
			"uint_fast64_t H(int n, int r) {",
			"    if (n == 0 and r == 0) return 1;",
			"    return C(n + r - 1, r);",
			"}",
			"",
			"/*",
			"・組み合わせ, 順列, 重複組み合わせ",
			"    > 前計算 O(MAX_N + logMOD)",
			"    > クエリ O(1)",
			"[備考] nが負の際, C(n, r) = (-1) ^ r * C(-n + r - 1, r)として計算.",
			"[使用例]",
			"COMinit();  // MAX_Nまでの前計算",
			"C(n, r);    // nCr (0 <= (n,r) <= MAX_N)",
			"P(n, r);    // nPr ( ... )",
			"H(n, r);    // nHr ( ... )",
			"[verify] https://yukicoder.me/submissions/380715",
			"*/",
		],
	},
	"組み合わせ (パスカルの三角形)": {
		"prefix": [
			"math",
			"combination",
			"pascal",
		],
		"body": [
			"uint_fast64_t comb(uint_fast64_t n, uint_fast32_t r) {",
			"    if (r == 0) return 1;",
			"    if (n < 0) return comb(-n + r - 1, r) * (r % 2 ? -1 : 1);",
			"    if (n == 0 || r < 0 || n < r) return 0;",
			"    uint_fast64_t ret = 1;",
			"    for (uint_fast64_t i = 1; i <= r; ++i) (ret *= n--) /= i;",
			"    return ret;",
			"}",
			"",
			"/*",
			"・nが大きい(rが小さい)ときの組み合わせ",
			"    > クエリ O(r)",
			"[使用例] comb(n, r);     // nCr",
			"*/",
		],
	},
	"約数列挙 O(√n)": {
		"prefix": [
			"math",
			"divisor",
			"prime",
		],
		"body": [
			"vector<int_fast64_t> divisor(const int_fast64_t n) {",
			"    vector<int_fast64_t> ret;",
			"    for (int_fast64_t i = 1; i * i <= n; ++i) {",
			"        if (n % i == 0) {",
			"            ret.emplace_back(i);",
			"            if (i * i != n) ret.emplace_back(n / i);",
			"        }",
			"    }",
			"    // sort(ret.begin(), ret.end());",
			"    return ret;",
			"}",
			"",
			"/*",
			"・約数列挙",
			"    > O(√n)",
			"[使用例] vector<int_fast64_t> div = divisor(105);",
			"[備考] 整列されていない.",
			"*/",
		],
	},
	"エラトステネスの篩 O(NloglogN)": {
		"prefix": [
			"math",
			"eratosthenes",
			"prime",
		],
		"body": [
			"vector<bool> Eratosthenes(const int n) {",
			"    vector<bool> r(n + 1, true);",
			"    for (int i = 2; i * i <= n; ++i) {",
			"        if (r[i]) {",
			"            for (int j = i * 2; j <= n; j += i) r[j] = false;",
			"        }",
			"    }",
			"    if (r.size() > 2) {",
			"        r[0] = r[1] = false;",
			"    } else if (r.size() > 1) {",
			"        r[0] = false;",
			"    }",
			"    return r;",
			"}",
			"",
			"/*",
			"・エラトステネスの篩",
			"    > O(NloglogN)",
			"[使用例] vector<bool> prime = Eratosthenes(100000);",
			"[備考] nが10^6以下のときに使うべき.",
			"*/",
		],
	},
	"素数判定 O(√n)": {
		"prefix": [
			"math",
			"prime",
		],
		"body": [
			"bool isPrime(int_fast64_t n) {",
			"    if (n < 2) return false;",
			"    for (int i = 2; i * i <= n; ++i) if (n % i == 0) return false;",
			"    return true;",
			"}",
			"",
			"/*",
			"・素数判定",
			"    > O(√n)",
			"[使用例] isPrime(998244353);    // == true",
			"*/",
		],
	},
	"素因数分解(約数の個数) O(√n)": {
		"prefix": [
			"math",
			"prime",
			"divisor",
		],
		"body": [
			"map<int_fast64_t, int> prime_factor(int_fast64_t n) {",
			"    map<int_fast64_t, int> ret;",
			"    for (int_fast64_t i = 2; i * i <= n; ++i) {",
			"        while (n % i == 0) {",
			"            ++ret[i];",
			"            n /= i;",
			"        }",
			"    }",
			"    if (n != 1) ret[n] = 1;",
			"    return ret;",
			"}",
			"",
			"/*",
			"・素因数分解",
			"    > O(√n)",
			"[使用例] map<int_fast64_t, int> mp = prime_factor(105);",
			"[応用例] (mpの各要素のsecond) + 1を掛け合わせると, nの約数の個数",
			"*/",
		],
	},
	"行列演算": {
		"prefix": [
			"math",
			"matrix",
		],
		"body": [
			"template< class T > struct Matrix {",
			"    vector< vector< T > > A;",
			"    Matrix() {}",
			"    Matrix(size_t n, size_t m) : A(n, vector< T >(m, 0)) {}",
			"    Matrix(size_t n) : A(n, vector< T >(n, 0)) {};",
			"    size_t height() const { return (A.size()); }",
			"    size_t  width() const { return (A[0].size()); }",
			"    inline const vector< T > &operator[](int k) const { return (A.at(k)); }",
			"    inline       vector< T > &operator[](int k)       { return (A.at(k)); }",
			"    static Matrix I(size_t n) {",
			"        Matrix mat(n);",
			"        for (int i = 0; i < n; ++i) mat[i][i] = 1;",
			"        return (mat);",
			"    }",
			"    Matrix& operator+=(const Matrix &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for (int i = 0; i < n; ++i)",
			"            for (int j = 0; j < m; ++j)",
			"                (*this)[i][j] += B[i][j];",
			"        return (*this);",
			"    }",
			"    Matrix& operator-=(const Matrix &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for(int i = 0; i < n; i++)",
			"            for(int j = 0; j < m; j++)",
			"                (*this)[i][j] -= B[i][j];",
			"        return (*this);",
			"    }",
			"    Matrix& operator*=(const Matrix &B) {",
			"        size_t n = height(), m = B.width(), p = width();",
			"        assert(p == B.height());",
			"        vector< vector< T > > C(n, vector< T >(m, 0));",
			"        for(int i = 0; i < n; i++)",
			"            for(int j = 0; j < m; j++)",
			"                for(int k = 0; k < p; k++)",
			"                    C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
			"        A.swap(C);",
			"        return (*this);",
			"    }",
			"    Matrix& operator^=(long long k) {",
			"        Matrix B = Matrix::I(height());",
			"        while (k > 0) {",
			"            if (k & 1) B *= *this;",
			"            *this *= *this;",
			"            k >>= 1LL;",
			"        }",
			"        A.swap(B.A);",
			"        return *this;",
			"    }",
			"    Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }",
			"    Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }",
			"    Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }",
			"    Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }",
			"    friend ostream &operator<<(ostream &os, Matrix &p) {",
			"        size_t n = p.height(), m = p.width();",
			"        for (int i = 0; i < n; i++) {",
			"            os << '[';",
			"            for (int j = 0; j < m; j++) {",
			"                os << p[i][j] << (j + 1 == m ? \"]\\\\n\" : ',');",
			"            }",
			"        }",
			"        return os;",
			"    }",
			"    T determinant() {",
			"        Matrix B(*this);",
			"        assert(width() == height());",
			"        T ret = 1;",
			"        for (int i = 0; i < width(); i++) {",
			"            int idx = -1;",
			"            for (int j = i; j < width(); j++) if (B[j][i] != 0) idx = j;",
			"            if (idx == -1) return (0);",
			"            if (i != idx) { ret *= -1; swap(B[i], B[idx]); }",
			"            ret *= B[i][i];",
			"            T vv = B[i][i];",
			"            for (int j = 0; j < width(); j++) B[i][j] /= vv;",
			"            for (int j = i + 1; j < width(); j++) {",
			"                T a = B[j][i];",
			"                for (int k = 0; k < width(); k++) B[j][k] -= B[i][k] * a;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"",
			"/*",
			"・行列演算",
			"[使用例]",
			"Matrix<int> mat(n,m);   // n行m列の行列を定義",
			"mat[i][j];              // i行j列目の要素を取得",
			"mat.determinant();      // matの行列式を計算",
			"mat ^= k;               // matのk乗を計算",
			"*/",
		],
	},
	"F_2上の行列演算": {
		"prefix": [
			"math",
			"matrix",
			"bit",
		],
		"body": [
			"const int MAX_ROW = 510;",
			"const int MAX_COL = 510;",
			"struct BitMatrix {",
			"    int H, W;",
			"    bitset<MAX_COL> val[MAX_ROW];",
			"    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}",
			"    inline bitset<MAX_COL>& operator[](int i) { return val[i]; }",
			"};",
			"ostream& operator<<(ostream& s, BitMatrix A) {",
			"    s << endl;",
			"    for (int i = 0; i < A.H; ++i) {",
			"        for (int j = 0; j < A.W; ++j) {",
			"            s << A[i][j] << \", \";",
			"        }",
			"        s << endl;",
			"    }",
			"    return s;",
			"}",
			"inline BitMatrix operator*(BitMatrix A, BitMatrix B) {",
			"    BitMatrix R(A.H, B.W), tB(B.W, B.H);",
			"    for (int i = 0; i < tB.H; ++i) for (int j = 0; j < tB.W; ++j) tB[i][j] = B[j][i];",
			"    for (int i = 0; i <  R.H; ++i) for (int j = 0; j <  R.W; ++j)  R[i][j] = ((A[i] & tB[j]).count() & 1);",
			"    return R;",
			"}",
			"inline BitMatrix pow(BitMatrix A, uint_fast64_t n) {",
			"    BitMatrix R(A.H, A.H);",
			"    for (int i = 0; i < A.H; ++i) R[i][i] = 1;",
			"    while (n > 0) {",
			"        if (n & 1) R = R * A;",
			"        A = A * A;",
			"        n >>= 1;",
			"    }",
			"    return R;",
			"}",
			"int gaussian_elimination(BitMatrix &A, bool is_extended = false) {",
			"    int rank = 0;",
			"    for (int col = 0; col < A.W; ++col) {",
			"        if (is_extended and col == A.W - 1) break;",
			"        int pivot = -1;",
			"        for (int row = rank; row < A.H; ++row) {",
			"            if (A[row][col]) {",
			"                pivot = row;",
			"                break;",
			"            }",
			"        }",
			"        if (pivot == -1) continue;",
			"        swap(A[pivot], A[rank]);",
			"        for (int row = 0; row < A.H; ++row) {",
			"            if (row != rank and A[row][col]) A[row] ^= A[rank];",
			"        }",
			"        ++rank;",
			"    }",
			"    return rank;",
			"}",
			"int linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {",
			"    int m = A.H, n = A.W;",
			"    BitMatrix M(m, n + 1);",
			"    for (int i = 0; i < m; ++i) {",
			"        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];",
			"        M[i][n] = b[i];",
			"    }",
			"    int rank = gaussian_elimination(M, true);",
			"    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;",
			"    res.assign(n, 0);",
			"    for (int i = 0; i < rank; ++i) res[i] = M[i][n];",
			"    return rank;",
			"}",
			"",
			"/*",
			"・BitMatrix",
			"[備考] F_2上の行列操作",
			"[注意] MAX_ROW, MAX_COLを問題ごとに変えること",
			"[使用例]",
			"BitMatrix mat(N, M);            // N行M列の行列を作成",
			"gaussian_elimination(mat);      // matに対してガウスの消去法を適用",
			"linear_equation(A, b, res);     // 連立方程式 A * res = b を解く",
			"*/",
		],
	},
	"ModInt": {
		"prefix": [
			"math",
			"modint",
		],
		"body": [
			"template< int MODULO > struct ModInt {",
			"    using int64 = int_fast64_t;",
			"    using uint32 = uint_fast32_t;",
			"    using uint64 = uint_fast64_t;",
			"    uint64 x; ModInt() : x(0) {}",
			"    ModInt(uint64 y) : x(set(y % MODULO + MODULO)) {}",
			"    static uint64 set(const uint64 &y) { return (y < MODULO) ? y : y - MODULO; }",
			"    static ModInt make(const uint64 &y) { ModInt ret = y; return ret; }",
			"    ModInt operator+(const ModInt &m) const { return make(set(x + m.x)); }",
			"    ModInt operator-(const ModInt &m) const { return make(set(x + MODULO - m.x)); }",
			"    ModInt operator*(const ModInt &m) const { return make(x * m.x % MODULO); }",
			"    ModInt operator/(const ModInt &m) const { return make(x) * ~make(m.x); }",
			"    ModInt &operator+=(const ModInt &m) { return *this = *this + m; }",
			"    ModInt &operator-=(const ModInt &m) { return *this = *this - m; }",
			"    ModInt &operator*=(const ModInt &m) { return *this = *this * m; }",
			"    ModInt &operator/=(const ModInt &m) { return *this = *this / m; }",
			"    ModInt &operator^=(const uint64 &y) { return *this = *this ^ y; }",
			"    ModInt operator~ () const { return *this ^ (MODULO - 2); }",
			"    ModInt operator- () const { return make(set(MODULO - x)); }",
			"    ModInt operator! () const { init(uint32(*this)); return fact[uint32(*this)]; }",
			"    ModInt operator& () const { init(uint32(*this)); return finv[uint32(*this)]; }",
			"    ModInt operator++() { return *this = make(set(x + 1)); }",
			"    ModInt operator--() { return *this = make(set(x + MODULO - 1)); }",
			"    bool operator==(const ModInt &m) const { return x == m.x; }",
			"    bool operator!=(const ModInt &m) const { return x != m.x; }",
			"    bool operator< (const ModInt &m) const { return x <  m.x; }",
			"    bool operator<=(const ModInt &m) const { return x <= m.x; }",
			"    bool operator> (const ModInt &m) const { return x >  m.x; }",
			"    bool operator>=(const ModInt &m) const { return x >= m.x; }",
			"    explicit operator   bool() const { return x; }",
			"    explicit operator uint64() const { return x; }",
			"    ModInt operator^(uint64 y) const {",
			"        uint64 t = x, u = 1;",
			"        while (y) { if (y & 1) (u *= t) %= MODULO; (t *= t) %= MODULO; y >>= 1; }",
			"        return make(u);",
			"    }",
			"    friend ostream &operator<<(ostream &os, const ModInt< MODULO > &m) { return os << m.x; }",
			"    friend istream &operator>>(istream &is, ModInt< MODULO > &m) { uint64 y; is >> y; m = make(y); return is; }",
			"    static vector< ModInt > fact, finv, invs;",
			"    static void init(uint32 n) {",
			"        uint32 m = fact.size();",
			"        if (n < m) return;",
			"        fact.resize(n + 1, 1);",
			"        finv.resize(n + 1, 1);",
			"        invs.resize(n + 1, 1);",
			"        if (m == 0) m = 1;",
			"        for (uint32 i = m; i <= n; ++i) fact[i] = fact[i - 1] * ModInt(i);",
			"        finv[n] = ModInt(1) / fact[n];",
			"        for (uint32 i = n; i >= m; --i) finv[i - 1] = finv[i] * make(i);",
			"        for (uint32 i = m; i <= n; ++i) invs[i] = finv[i] * fact[i - 1];",
			"    }",
			"    static ModInt C(int64 n, int64 r) {",
			"        if (r == 0) return make(1);",
			"        if (r <  0) return make(0);",
			"        if (n <  0) return make(r & 1 ? MODULO - 1 : 1) * C(-n + r - 1, r);",
			"        if (n == 0 || n < r) return make(0);",
			"        init(n);",
			"        return fact[n] * finv[n - r] * finv[r];",
			"    }",
			"    static ModInt P(int64 n, int64 r) {",
			"        if (n < r || r < 0) return make(0);",
			"        init(n);",
			"        return fact[n] * finv[n - r];",
			"    }",
			"    static ModInt H(int64 n, int64 r) {",
			"        if (n < 0 || r < 0) return make(0);",
			"        if (!n && !r) return make(1);",
			"        init(n + r - 1);",
			"        return C(n + r - 1, r);",
			"    }",
			"    static ModInt montmort(uint32 n) {",
			"        ModInt res;",
			"        init(n);",
			"        for (uint32 k = 2; k <= n; ++k) {",
			"            if (k & 1) res -= finv[k];",
			"            else res += finv[k];",
			"        }",
			"        return res *= fact[n];",
			"    }",
			"    static ModInt LagrangePolynomial(vector<ModInt> &y, ModInt t) {",
			"        uint32 n = y.size() - 1;",
			"        if (t.x <= n) return y[t.x];",
			"        init(n + 1);",
			"        ModInt res, num(1);",
			"        for (uint32 i = 0; i <= n; ++i) num *= t - make(i);",
			"        for (uint32 i = 0; i <= n; ++i) {",
			"            ModInt tmp = y[i] * num / (t - make(i)) * finv[i] * finv[n - i];",
			"            if ((n - i) & 1) res -= tmp;",
			"            else res += tmp;",
			"        }",
			"        return res;",
			"    }",
			"};",
			"template< int MODULO >",
			"vector<ModInt< MODULO >> ModInt< MODULO >::fact = vector<ModInt< MODULO >>();",
			"template< int MODULO >",
			"vector<ModInt< MODULO >> ModInt< MODULO >::finv = vector<ModInt< MODULO >>();",
			"template< int MODULO >",
			"vector<ModInt< MODULO >> ModInt< MODULO >::invs = vector<ModInt< MODULO >>();",
			"using modint = ModInt< MOD >;",
			"",
			"/*",
			"・ModInt",
			"[備考] Mod演算のための構造体",
			"[使用例]",
			"modint M;           // 剰余系MOD(1e9+7)における演算ができる",
			"ModInt<mod> N;      // 剰余系modにおける演算ができる",
			"*/",
		],
	},
	"ローリングハッシュ": {
		"prefix": [
			"string",
			"rolling hash",
		],
		"body": [
			"template<int mod, int base=10007>",
			"struct RollingHash {",
			"    vector<uint_fast64_t> hsh, pwr;",
			"    uint_fast64_t umod(uint_fast64_t n) { return (n % mod + mod) % mod; }",
			"    RollingHash() {}",
			"    RollingHash(const string &s) {",
			"        int sz = (int)s.size();",
			"        hsh.assign(sz + 1, 0);",
			"        pwr.assign(sz + 1, 0);  pwr[0] = 1;",
			"        for (int i = 0; i < sz; ++i) {",
			"            if (sz > i) hsh[i + 1] = umod(hsh[i] * base + s[i]);",
			"            pwr[i + 1] = umod(pwr[i] * base);",
			"        }",
			"    }",
			"    // [l, r)",
			"    uint_fast64_t get(int l, int r) {",
			"        return umod(hsh[r] - hsh[l] * pwr[r - l]);",
			"    }",
			"    // h1 <- h2",
			"    uint_fast64_t join(uint_fast64_t h1, uint_fast64_t h2, int h2_sz) {",
			"        return umod(h1 * pwr[h2_sz] + h2);",
			"    }",
			"    // [idx, len_s) + [0, idx)",
			"    uint_fast64_t rotate(uint_fast64_t idx, int len_s) {",
			"        return join(get(idx, len_s), get(0, idx), idx);",
			"    }",
			"};",
			"using RH1 = RollingHash<(int)1e9 + 7>;",
			"using RH2 = RollingHash<(int)1e9 + 9>;",
			"using RH = pair<RH1, RH2>;",
			"using H = pair<uint_fast64_t, uint_fast64_t>;",
			"RH init(const string &s) { return make_pair(RH1(s), RH2(s)); }",
			"H get(RH &rh, int l, int r) { return make_pair(rh.first.get(l, r), rh.second.get(l, r)); }",
			"H rotate(RH &rh, int n, int sz) { return make_pair(rh.first.rotate(n, sz), rh.second.rotate(n, sz)); }",
			"",
			"/*",
			"・ローリングハッシュ",
			"[備考] 文字列をハッシュとして管理する. ハッシュ値の衝突に注意.",
			"[使用例]",
			"RH rh = init(S);            // 文字列Sでハッシュを構築",
			"get(rh, l, r);              // 半開区間[l, r)のハッシュ値を取得",
			"rotate(rh, idx, len_s);     // 文字列をidxの位置でrotateしたものを返す",
			"[ToDo] 回文判定",
			"*/",
		],
	},
	"Suffix Array": {
		"prefix": [
			"string",
			"suffix array",
		],
		"body": [
			"struct SuffixArray {",
			"    vector<int> SA;",
			"    string s;",
			"    SuffixArray(string &s) : s(s) {",
			"        SA.resize(s.size());",
			"        iota(begin(SA), end(SA), 0);",
			"        sort(begin(SA), end(SA), [&](int a, int b) {",
			"            return (s[a] == s[b]) ? a > b : s[a] < s[b];",
			"        });",
			"        vector<int> classes(s.size()), c(s.begin(), s.end()), cnt(s.size());",
			"        for (int l = 1; l < s.size(); l <<= 1) {",
			"            for (int i = 0; i < s.size(); i++) {",
			"                if (i > 0 and c[SA[i - 1]] == c[SA[i]]",
			"                          and   SA[i - 1] + l < s.size()",
			"                          and c[SA[i - 1] + l / 2] == c[SA[i] + l / 2]) {",
			"                    classes[SA[i]] = classes[SA[i - 1]];",
			"                } else {",
			"                    classes[SA[i]] = i;",
			"                }",
			"            }",
			"            iota(begin(cnt), end(cnt), 0);",
			"            copy(begin(SA), end(SA), begin(c));",
			"            for (int i = 0; i < s.size(); i++) {",
			"                int s1 = c[i] - l;",
			"                if (s1 >= 0) SA[cnt[classes[s1]]++] = s1;",
			"            }",
			"            classes.swap(c);",
			"        }",
			"    }",
			"    bool lt_substr(const string &t, int si = 0, int ti = 0) {",
			"        int sn = (int)s.size(), tn = (int)t.size();",
			"        while (si < sn and ti < tn) {",
			"            if (s[si] < t[ti]) return true;",
			"            if (s[si] > t[ti]) return false;",
			"            ++si, ++ti;",
			"        }",
			"        return si >= sn and ti < tn;",
			"    }",
			"    int lower_bound(const string &t) {",
			"        int low = -1, high = (int)SA.size();",
			"        while (high - low > 1) {",
			"            int mid = (low + high) / 2;",
			"            if (lt_substr(t, SA[mid])) low = mid;",
			"            else high = mid;",
			"        }",
			"        return high;",
			"    }",
			"    pair<int, int> lower_upper_bound(string &t) {",
			"        int idx = lower_bound(t);",
			"        int low = idx - 1, high = (int)SA.size();",
			"        t.back()++;",
			"        while (high - low > 1) {",
			"            int mid = (low + high) / 2;",
			"            if (lt_substr(t, SA[mid])) low = mid;",
			"            else high = mid;",
			"        }",
			"        t.back()--;",
			"        return make_pair(idx, high);",
			"    }",
			"    void debug() {",
			"        for (int i = 0; i < size(); ++i) {",
			"            cerr << i << \" : \" << s.substr(SA[i]) << endl;",
			"        }",
			"    }",
			"};",
			"",
			"/*",
			"・SuffixArray",
			"    > 構築 : O(NlogN)   [N : 文字列長]",
			"    > クエリ : O(MlogN) [M : パターン長]",
			"[使用例]",
			"SuffixArray sa(S);          // 文字列Sに対するSuffixArrayを構築",
			"sa.lower_upper_bound(T);    // 文字列Tを含む接尾辞のindexの下限と上限を返す",
			"*/",
		],
	},
	"座標圧縮 O(NlogN)": {
		"prefix": [
			"compression",
			"zaatu",
		],
		"body": [
			"// template<typename T> vector<T> compress(vector<T> ord, map<T, int> &rev) {",
			"template<typename T> vector<T> compress(vector<T> ord) { map<T, int> rev;",
			"    vector< T > com = ord;",
			"    sort(com.begin(), com.end());",
			"    com.erase(unique(com.begin(), com.end()), com.end());",
			"    for (int i = 0; i < com.size(); ++i) rev[com[i]] = i;",
			"    vector< T > ret; for (auto& e : ord) ret.emplace_back(rev[e]);",
			"    return ret;",
			"}",
			"",
			"/*",
			"・座標圧縮",
			"    > O(NlogN)",
			"[備考] 各数字の対応関係が欲しいときは, 引数にmapを入れてコメントアウトを外す.",
			"[使用例]",
			"1. 引数にmapを入れない場合",
			"vector<long long> com = compress(v);",
			"2. 引数にmapを入れる場合",
			"map<long long, int> rev;",
			"vector<long long> com = compress(v, rev);",
			"*/",
		],
	},
	"文字列と整数同士の変換": {
		"prefix": [
			"conversion",
			"string",
			"integer",
		],
		"body": [
			"inline uint_fast64_t toInt(string s) {",
			"    uint_fast64_t v;",
			"    istringstream sin(s);",
			"    sin >> v;",
			"    return v;",
			"}",
			"template<typename T> inline string toString(T x) {",
			"    ostringstream sout;",
			"    sout << x;",
			"    return sout.str();",
			"}",
			"template<typename T> inline void ntos(const T &n, string &s) {",
			"    stringstream stream;",
			"    stream << n;",
			"    stream >> s;",
			"}",
			"template<typename T> inline void ston(const string &s, T &n) {",
			"    stringstream stream(s);",
			"    stream >> n;",
			"}",
			"",
			"/*",
			"・文字列と整数同士の変換",
			"[使用例]",
			"toInt(\"222\") / 2    // == 111",
			"toString(222) + 2   // == 224",
			"int n = 9876; string t; ntos(n, t);     // t == \"9876\"",
			"string s = \"1234\"; int m; ston(s, m);   // m == 1234",
			"*/",
		],
	},
	"サイコロ": {
		"prefix": [
			"dice",
		],
		"body": [
			"// 下にy, 右にx",
			"enum { R, U, L, D };",
			"int dx[] = { 1,  0, -1, 0 };",
			"int dy[] = { 0, -1,  0, 1 };",
			"",
			"struct Dice {",
			"    int T, N, E, S, W, B;",
			"    int table[6][6] = {",
			"        { 0, 3, 5, 2, 4, 0 },",
			"        { 4, 0, 1, 6, 0, 3 },",
			"        { 2, 6, 0, 0, 1, 5 },",
			"        { 5, 1, 0, 0, 6, 2 },",
			"        { 3, 0, 6, 1, 0, 4 },",
			"        { 0, 4, 2, 5, 3, 0 }",
			"    };",
			"    Dice(int T, int S) : T(T), S(S) { build(); }",
			"    void build() {",
			"        E = table[T - 1][S - 1];",
			"        tie(N, W, B) = make_tuple(7 - S, 7 - E, 7 - T);",
			"        // swap(E, W);  // もう1種類のサイコロの場合",
			"    }",
			"    void rot(int dir) {",
			"        if (dir == R) tie(T, S) = make_pair(W, S);",
			"        if (dir == U) tie(T, S) = make_pair(S, B);",
			"        if (dir == L) tie(T, S) = make_pair(E, S);",
			"        if (dir == D) tie(T, S) = make_pair(N, T);",
			"        // tie(T, S) = (vector<pair<int,int>>){{W, S}, {S, B}, {E, S}, {N, T}}[dir];",
			"        build();",
			"    }",
			"    int get(int m) {",
			"        return (vector<int>){E, N, W, S}[m];",
			"    }",
			"};",
			"",
			"/*",
			"・サイコロ",
			"[使用例]",
			"Dice dc(T, S);      // TとSが下図のような位置関係のサイコロを作成",
			"dc.rot(R);          // 右方向に回転",
			"dc.get(idx);        // 側面の目を返す(ループを回すときに使う) ここでは{R, U, L, D}の順",
			"       _______",
			"      /\      \           N(U)",
			"     /  \   T  \           |            4",
			"    /    \______\  W(L) - T,B - E(R)  2 1 5 6",
			"    \ S  /      /          |            3",
			"     \  /   E  /          S(D)",
			"      \/______/",
			"*/",
		],
	},
	"ランレングス圧縮": {
		"prefix": [
			"groupby",
			"run length compression",
		],
		"body": [
			"template<typename T> vector< pair< T, int > > groupby(const vector< T > &vec) {",
			"    vector< pair< T, int > > ret;",
			"    int piv = -1;",
			"    for (auto &e: vec) {",
			"        if (piv == -1 or ret[piv].first != e) ++piv, ret.emplace_back(make_pair(e, 1));",
			"        else ++(ret[piv].second);",
			"    }",
			"    return ret;",
			"}",
			"",
			"/*",
			"・ランレングス圧縮",
			"[備考] stringについて用いる場合は, vector<char>に以下のようにして一旦移し替える.",
			"      string str;",
			"      vector<char> vec(str.begin(), str.end());",
			"[使用例]",
			"vector<int> vec = {1, 5, 5, 7, 7, 7, 7};",
			"auto gb = groupby(vec);     // {{1, 1}, {5, 2}, {7, 4}}",
			"[蛇足] 命名はPythonに準拠",
			"*/",
		],
	},
	"転倒数": {
		"prefix": [
			"math",
			"inversion number",
			"tentousuu",
		],
		"body": [
			"template<typename T> int_fast64_t InversionNumber(vector< T > &v) {",
			"    int_fast64_t sz = v.size(), ret = 0;",
			"    vector< T > rev, v_cp = v; sort(v_cp.begin(), v_cp.end());",
			"    for (auto &e : v) rev.emplace_back(lower_bound(v_cp.begin(), v_cp.end(), e) - v_cp.begin());",
			"    BinaryIndexedTree< T > bit(sz);",
			"    for (int i = 0; i < sz; ++i) {",
			"        ret += i - bit.sum(rev[i]);",
			"        bit.add(rev[i], 1);",
			"    }",
			"    return ret;",
			"}",
			"",
			"/*",
			"・転倒数 (Inversion Number)",
			"    > O(NlogN)",
			"[備考] i < j かつ a_i > a_j となる組(i, j)の個数. バブルソートのスワップ回数と等しい.",
			"[注意] BinaryIndexedTreeを上で定義しておくこと.",
			"[使用例]",
			"vector<int> v = {3, 1, 5, 4, 2};",
			"InversionNumber(v);     // == 5 : vの転倒数",
			"*/",
		],
	},
	"LimitInt": {
		"prefix": [
			"math",
			"limitint",
		],
		"body": [
			"template<typename T> struct LimitInt {",
			"    T x;",
			"    const T low, high;",
			"    T get() const { return x; }",
			"    LimitInt() : x(0), low(numeric_limits< T >::min() + 10), high(numeric_limits< T >::max() - 10) {}",
			"    LimitInt(const T &x) : x(x), low(numeric_limits< T >::min() + 10), high(numeric_limits< T >::max() - 10) {}",
			"    LimitInt& operator+=(const LimitInt &y) { x = (double) x + y.x > high ? high : x + y.x; return (*this); }",
			"    LimitInt& operator-=(const LimitInt &y) { x = (double) x - y.x <  low ?  low : x - y.x; return (*this); }",
			"    LimitInt& operator*=(const LimitInt &y) { x = (double) x * y.x > high ? high : x * y.x; return (*this); }",
			"    LimitInt& operator/=(const LimitInt &y) { x /= y.x;                                     return (*this); }",
			"    LimitInt operator-() const { return -x; }",
			"    LimitInt operator+(const LimitInt &y) const { LimitInt ret(x); ret += y; return ret; }",
			"    LimitInt operator-(const LimitInt &y) const { LimitInt ret(x); ret -= y; return ret; }",
			"    LimitInt operator*(const LimitInt &y) const { LimitInt ret(x); ret *= y; return ret; }",
			"    LimitInt operator/(const LimitInt &y) const { LimitInt ret(*this); ret /= y; return ret; }",
			"    LimitInt operator==(const LimitInt &y) const { return (x == y.x); }",
			"    LimitInt operator!=(const LimitInt &y) const { return (x != y.x); }",
			"    LimitInt operator< (const LimitInt &y) const { return (x <  y.x); }",
			"    LimitInt operator> (const LimitInt &y) const { return (x >  y.x); }",
			"    LimitInt operator<=(const LimitInt &y) const { return (x <= y.x); }",
			"    LimitInt operator>=(const LimitInt &y) const { return (x >= y.x); }",
			"};",
			"",
			"/*",
			"・LimitInt",
			"[備考] 加減乗除の演算に対して, 値の上限と下限を設定する",
			"*/",
		],
	},
	"多倍長整数 / 浮動小数点数": {
		"prefix": [
			"multiprecision",
			"tabaichou",
		],
		"body": [
			"#include <boost/multiprecision/cpp_int.hpp>",
			"#include <boost/multiprecision/cpp_dec_float.hpp>",
			"using Bint = boost::multiprecision::cpp_int;",
			"using Bfloat32 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32> >;",
			"using Bfloat1024 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<1024> >;",
			"",
			"/*",
			"・多倍長整数 Bint",
			"[使用例] Bint num;     // 任意精度の符号あり多倍長整数",
			"https://boostjp.github.io/tips/multiprec-int.html",
			"・多倍長浮動小数点数 Bfloat",
			"[使用例] Bfloat32 f;   // 仮数部が32bitの符号あり浮動小数点数",
			"https://boostjp.github.io/tips/multiprec-float.html",
			"*/",
		],
	},
}
